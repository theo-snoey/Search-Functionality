https://cs106b.stanford.edu/about_assignments
Due Date Assignment Materials Mon, Feb. 5 A3. TBA Mon, Jan. 29 A2. Fun with Collections Mon, Jan. 22 A1. Getting Your C++ Legs Fri, Jan. 12 A0. Welcome to CS106B! Programming is a skill best learned by doing, and the programming assignments in CS106B form the central skill development part of your experience in the course. We have a great set of assignments planned that we hope you will find fun, challenging, illuminating, and rewarding! Common questions about assignments What is the development environment for the assignments? In CS106B, we write programs in the C++ language and use the Qt Creator IDE for editing, compiling, and debugging. Visit the Qt Installation Guide for instructions on installing these tools on your computer. What is the expected assignment workload? There are 7 assignments, you typically will have one week to work on each. Students self-report spending between 10 and 20 hours on each assignment. If you find yourself consistently beyond the upper end of the range, please reach out to us. Our workload is challenging because we want to foster the most growth possible for you in our 10 weeks together, but we do want the total hours to stay within reason for a 5-unit course and can help find a strategy that works for you. What is the policy on late assignments? This quarter, everyone has four late days to use on programming assignments at their discretion. Late days are expended in 24-hour blocks (so, submitting an assignment 4.5 hours late uses one full late day; submitting 27 hours late uses two full late days). No assignment may be submitted more than 48 hours late. In other words, you cannot use more than two late days on a single assignment. We strongly encourage you to start all assignments as soon as they're posted (even if that means just glancing through the write-up to see what the assignment is all about) and to reserve your late days for situations in which you would normally reach out to an instructor to ask for an extension on an assignment (e.g., illness). Late submissions put extra pressure on your section leader to return feedback to you in a timely manner. We ask that you use them only when your situation requires it. We do not anticipate granting further extensions on top of this late submission policy except in extreme circumstances. Only your instructor and Head TA can grant such extensions. Please reach out to us if you need to discuss, and please refrain from asking your section leader for an extension, as they do not have the authority to grant one. Note that assignments are due at 11:59 PM. Any submissions that come after 11:59 PM will be considered late. If you make multiple submissions for an assignment, we grade the last one, without exception. If you submit an assignment late and have used your late days, we will cap your score on both functionality and style at for the purposes of grading (though in your interactive grading session you'll still be shown the scores you would have otherwise received on the assignment so that you get more detailed feedback). Note that given the tight turnaround time associated with grading the final programming assignment in the course, late days cannot be used toward that assignment. However, you will be given more time to complete that assignment than the other ones in the course. What is the assignment collaboration policy? Since this is essentially a beginning writing course, but writing code instead of essays, our policy is that assignments are written individually (no partners/groups). Later CS courses may incorporate team-based projects, and we strongly believe in the value of that-but after programmers have developed their individual skills in the fundamentals. Please review the CS106B Honor Code policy for guidelines specific to this course (i.e., do not assume that what is ok in other classes is necessarily ok in this one). How can we get help on our assignments? Ask on our online discussion forum, bring questions to "Lair" helper hours, and/or attend office hours. Lair helper hours run 7-11pm Monday through Thurday. The forum is open 24/7 for discussion with your peers, and quick (though not 24/7, we do sleep!) answers from course staff. The instructor and Head TA are available to answer questions after lecture and in weekly office hours. How are assignments evaluated? Programs will be evaluated on "functionality" (is the program's behavior correct?) and "style" (is the code well written and elegant?). We apply a bucket grading scale for a wholistic qualitative evaluation rather than fixate on individual points. To learn from the grading feedback, focus your attention on the qualitative comments and the discussion with your SL in IGs. grade description + A submission that is "perfect" or exceeds our standard expectation for the assignment. To receive this grade, a program reflects additional work beyond the requirements or gets the job done in a particularly elegant way. (letter grade A+) A submission that satisfies all the requirements for the assignment, showing solid functionality as well as good style. It reflects a job well done. (letter grade range A/A-) A submission that mostly meets the requirements, with some small issues or oversights. (letter grade range B+/B) A submission that is a good attempt at meeting the requirements, but falls short in some ways. (letter grade range B-/C+) - A submission that exhibits serious problems, but nonetheless shows some effort and accomplishment. (letter grade range C/C-) -- A submission that shows low effort or does not represent passing work. (letter grade range D/NP) From past experience, we expect most grades to be and How do we receive feedback from our grader? You can view your submission on Paperless with comments and annotations from your grader along with the bucket scores for functionality and style. For some assignments, you will also meet with your section leader to discuss the grading feedback in a short IG ("interactive grading") conference.
https://cs106b.stanford.edu/about_exams
When Exam Materials Monday, March 18, 8:30 - 11:30 AM End-quarter exam Thursday, February 15, 7:00 - 9:00 PM Mid-quarter exam We have mid-quarter and end-quarter exams. The mid-quarter is a check-in to assess your understanding of core topics covered in the first half of the course and help you chart a path forward. The final is a comprehensive assessment of your mastery of the course learning goals. The midterm exam is scheduled for Thursday, February 15, 7:00 - 9:00 PM and final exam at Monday, March 18, 8:30 - 11:30 AM. We know that you work hard on completing your programming assignments, and that work forms the primary mechanism for growing your coding practice skills and learning the core concepts. Growing and learning is a journey, and each weekly assigmnment has the possibility for setbacks and redemption. Exams allow you to demonstrate that after all those assignment ups and downs, you eventually reached a place of mastery at the level we expect for this course. Watch this space for further details about exam logistics and practice problems to be released as the exams approach. Common questions about exams What is the format of the exams? The exams will be pen-and-paper, closed-book and closed-device. You will be provided with our standard reference sheet and can bring one page of your own prepared notes. Most questions will ask you to write a function that accomplishes a particular task. Other questions may ask you to read a provided passage of code and analyze or reason about its behavior. There may also be short answer questions to answer in prose. What is the policy on alternate/makeup exams? We very much appreciate your willingness in making arrangements to attend the out-of-class midterm at its scheduled time. If you have an unavoidable conflict, we will work with you to arrange an alternate time on that day. (There will be a place to give us a heads up about a conflict on Assignment 0). The final exam time is scheduled by the registrar; we will not offer any alternate finals. Please confirm you will be able to attend the final before enrolling in the course.
https://cs106b.stanford.edu/about_lectures
Date Lecture Materials Mon, Feb. 5 12. More Recursive Backtracking Fri, Feb. 2 11. Recursive Backtracking and Enumeration Wed, Jan. 31 10. Recursive Problem Solving Mon, Jan. 29 9. More Recursion Fri, Jan. 26 8. Big-O and Algorithmic Analysis Wed, Jan. 24 7. Introduction to Recursion Mon, Jan. 22 6. Sets and Maps Fri, Jan. 19 5. Stacks and Queues Wed, Jan. 17 4. Testing, Vectors, and Grids Fri, Jan. 12 3. C++ Strings Wed, Jan. 10 2. C++ Fundamentals Mon, Jan. 8 1. Welcome! Common questions about lectures Is lecture attendance required? We have scheduled our lecture to meet in the largest room available on campus. We strongly encourage all of you to join us in person! This will allow you to participate in class discussion and in-class activities, to ask your questions real-time, and ensures that you are keeping on pace with the course schedule. We think staying on pace with the class is so important (and we know you know it too-binge-watching videos just isn't it!) that we are offering a small grade incentive to help you motivate yourself to stay on top of it. How do lecture quizzes work? Here are the details: We will release a quiz on Canvas after each lecture. Quizzes will be due in weekly batches, usually on Wednesdays, 30 minutes prior to the start of lecture. The deadline for each quiz will be visible in Canvas. Since quizzes are released after each lecture but due in weekly batches, you will necessarily have more time to work on some quizzes than others. We understand this might seem wonky at first, but our hope is that the weekly deadline will feel more manageable than having a quiz due before each lecture. The batch deadlines should also afford you a reasonable degree of flexibility if you miss a class and have to fall back on the lecture video. At the end of the quarter, we will add a small bonus to your course grade based on the number of quizzes you completed and your scores on those quizzes. Hooray! Who doesn't love a direct boost to their grade for something that also solidifies their understanding of the material and helps them progress through the course at a consistent, manageable pace? Because quizzes are graded for bonus points only, we do not anticipate granting extensions on them under any circumstances. We ask that you pay careful attention to their deadlines in Canvas. Our goals with these lecture quizzes are: to give you a small grade incentive to help you motivate yourself to stay on top of lectures, which in turn should make this fast-paced course more manageable to help ensure everyone is caught up on relevant material before heading into section each week, which will enable more productive and meaningful group discussions to provide you with a timely, regular, low-stakes assessments of your understanding of the course material, so that you can identify any misunderstandings early and head to office hours straight away if you need clarification on anything Are lectures recorded? The winter quarter offering of CS106B will be recorded for our SCPD remote participants. Those video recordings are also available to regular on-campus for review or missed class. It sometimes takes about 2-3 hours after the end of class for the videos to post to Canvas, where they will appear under Panopto Course Videos. There is no live synchronous remote viewing. How can I ask questions during lecture? Raise your hand to ask it live. You also can ask questions during lecture via our online forum in a special megathread that will be continuously monitored by our head TA while lecture is happening.
https://cs106b.stanford.edu/about_resources
Course tools LaIR queue (helper hours) EdStem (discussion forum) Paperless (submit assignments) Canvas (lecture videos) Gradescope (graded exams) Course documents Programming Abstractions (PDF version of course textbook) Stanford Library documentation Code style guide SimpleTest guide Guide to Big-O notation Exam Prep Advice Submission checklist Honor Code CS106B Honor Code Policy C++ language and library refereence Python to C++ guide (transitioning from python to C++) C++ library reference Guide to C++ strings Qt Creator How to install Qt Creator Using Qt Creator Blank Qt project (template for creating a new CS106 project) For prospective students Course placement (choosing which Stanford course to start your CS journey) Common questions from prospective students
https://cs106b.stanford.edu/about_section
When Section Materials Week 5 S4. TBA Week 4 S3. TBA Week 3 S2. ADTs Week 2 S1. C++ fundamentals Common questions about section What are sections? Starting in Week 2, you'll meet in a weekly 50-minute small group discussion. The discussion will be facilitated by your section leader, who also serves as your mentor and grader. Each week we publish a set of section problems that follow onto the lecture topics and students will collaboratively work on these problems in section to deepen their understanding. How do I sign up for section? Section signups are handled on the CS198 section portal (do not sign-up for sections on Axess). The section portal will open signups on Thursday, January 11 at 5:00 pm and close on Sunday, January 14 at 5:00 pm. Section sign-ups are not first-come first-serve, rather all students rank their preferences and after submissions close, we arrange a workable schedule for everyone. Your assigned section will then be emailed to you. Where can I find my assigned section? You can find your section time and meeting location on Paperless. How do I prepare for section? The most important preparation for section is that you are up to date on lecture viewing. You don't need to have understood everything in lecture perfectly, but your section leader won't be able to effectively guide students through the problems unless everyone is at least caught up on viewing all of the lectures preceding the section. Where can I find the section problems? The section problems will be posted on the course website under the "Sections" tab at the beginning of each week. After all sections for the week have met, the section page is updated with the solutions for later review. Is section participation mandatory? How is it graded? Active participation in section is expected for all students. Choose a participation style that is comfortable for you, including asking questions, contributing answers, and participating in pair discussions with fellow students. Section participation is credited on this scale: 2 : Attended for full section period, came prepared, followed section norms, actively participated in an engaged manner 1 : Arrived late/left early or had limited participation, was not fully prepared 0 : Did not attend, or disregarded section norms, was not engaged Section participation contributes 5% to your final course grade. What should I do if I must miss a section meeting? You are welcome to attend an alternate section as a guest for a makeup. Visit the CS198 section portal for the full list of all section times. Tell the section leader whose section you attend that you're attending as a guest so they can pass the participation grade back to your section leader. You can also work the section problems on your own as self-review, but participation credit is specifically earned by attending and participating in a section. How do I become a section leader myself someday? You can apply during/after completing CS106B. Come join us! Information about applying can be found on the CS198 Website.
https://cs106b.stanford.edu/about_staff
Instructor: Sean szum@cs.stanford.edu Office Hours MWF 12:20 - 1:00 PM, Roaming After Lecture Head TA: Clinton ckwarteng@stanford.edu Office Hours Thurs, Friday 3:00 - 5:00 PM Durand 303 Instructor and TA office hours are open to all students, no sign up necessary, just drop in. Come ask your questions about concepts from lecture, request assignment help, and chat with us about Computer Science, advice, and life. Section leaders CS106B would not be possible without our wonderful team of undergraduate section leaders! In addition to leading small group sections, the SLs collectively run LaIR helper hours. LaIR is open for student questions and assignment help SMTuWTh evenings, 7:00 - 11:00 PM. More info about LaIR. Adarsh Alex Andrew Anshika Anushree Arisa Ben Benji Brandon Bryant Butch Cathy Claire Elena Ellie Everett Febie Gunnar Haven Iris Jack Jacob Javokhir Jenny Jessica Jesus Jonathan Joshua Justin Kate Keely Kenneth Kenny L'Hussen Lauren Naama Naomi Nathan Ngoc Noah Osose Ramya Renn Richard Sachin Tom Ty Usman Valerie Young
https://cs106b.stanford.edu/resources/bigo_guide.html
Big-O notation is a powerful tool for predicting how quickly a piece of code will run in a novel scenario. Once you know the big-O runtime of a piece of code, you can extrapolate its runtime, compare its performance against other alternative implementations, etc. But of course, that presumes you know how to get the big-O runtime of a piece of code. That skill - going from code to a big-O runtime - is a mix of an art and a science, and there are tons of beautiful strategies you can use to do it. This handout covers the basics of big-O runtime determination and gives several core techniques we recommend you use as you're getting started Technique 1: When in Doubt, Work Inside Out! Many pieces of code consist of several loops nested inside one another. When you see a piece of code like that, it's often helpful to analyze the runtime by starting with the most-deeply-nested loop and, from there, to work outwards toward the top-level loop. As an example, consider the following (silly, contrived) function: void omnesia(int n) { int total = 0; for (int i = 0; i < n * n; i++) { for (int j = 0; j < n; j++) { for (int k = 0; k < n; k++) { total++; } } } return total; } Our goal will be to work out the big-O runtime of this function. Since it consists of several nested loops, we'll begin with the most-deeply-nested loop, which is shown here: for (int k = 0; k < n; k++) { total++; } How much work does this loop do? Well, it runs for a total of n iterations, and each iteration does a constant amount of work (the work required to add one to total is independent of the values of n, k, etc.) Therefore, this loop does O(n) total work. With that in mind, we can "simplify" our original loop nest by replacing this innermost loop with something to the effect of "do O(n) work." That's shown here: void omnesia(int n) { int total = 0; for (int i = 0; i < n * n; i++) { for (int j = 0; j < n; j++) { for (int k = 0; k < n; k++) { total++; } } } return total; } void omnesia(int n) { int total = 0; for (int i = 0; i < n * n; i++) { for (int j = 0; j < n; j++) { /************************* * Do O(n) work * * **********************/ } } return total; } We've now reduced how much code there is here, leaving us with a simpler piece of code to analyze. And hey - if we can keep simplifying things over and over, then through the Vast Power of Recursion we'll eventually end up with something so easy we can solve it directly! We'll therefore repeat the previous process. We'll take the innermost loop in this code, which now looks like this: for (int j = 0; j < n; j++) { /************************* * Do O(n) work * * **********************/ } So - how much work does this loop do? Well, there will be O(n) total iterations of this loop (specifically, it's going to run n times). Each iteration of the loop does O(n) work, since that's literally what it says. Putting that together, we get Therefore, this loop does O(n 2 work. Feeding that back into our original code gives us this: void omnesia(int n) { int total = 0; for (int i = 0; i < n * n; i++) { for (int j = 0; j < n; j++) { /************************* * Do O(n) work * * **********************/ } } return total; } void omnesia(int n) { int total = 0; for (int i = 0; i < n * n; i++) { /************************* * * * Do O(n^2) work * * * * **********************/ } return total; } Let's now take the innermost loop of what remains, which is this one here: for (int i = 0; i < n * n; i++) { /************************* * * * Do O(n^2) work * * * * **********************/ } So, how much work does this do? Well, each loop iteration does O(n^2) work. The number of iterations of this loop is O(n^2) as well, since it runs n^2 times. Overall, this means that the loop does Simplifying our code once more gives us the following: void omnesia(int n) { int total = 0; for (int i = 0; i < n * n; i++) { /************************* * * * Do O(n^2) work * * * * **********************/ } return total; } void omnesia(int n) { int total = 0; /********************************* * * * * * Do O(n^4) work * * * * * ********************************/ return total; } At this point, we're left with code that declares a single integer variable, does O(n^4) work, then returns an integer. This takes, collectively, O(n^4) time, and so that's the overall runtime for this piece of code. Technique 2: Multiply When You Can, Add When You Can't In the examples up to this point, we've generally used a rule of thumb that goes like this: figure out how much work is done per iteration, then multiply that by the number of iterations, and you have your total work done. That technique is fine in cases where the amount of work done on each loop iteration is the same. However, that technique won't always work, and when that happens, you'll need to use other techniques. For this section, we'll use this piece of code as an example: void amniscience(int n) { for (int i = 0; i < n; i++) { for (int j = 0; j < i; j++) { for (int k = 0; k < 106; k++) { cout << '*'; } } } } We've got a stack of loops here, so, following the maxim of "when in doubt, work inside out!," we'll start with the innermost loop. That's this one here: for (int k = 0; k < 106; k++) { cout << '*'; } So - how much work does this loop do? It runs exactly 106 times, doing a constant amount of work per iteration. The number of iterations of this loop is completely independent of the values of n, i, j, etc. This loop always does the same amount of work, regardless of context. To indicate that it does a fixed amount of work that doesn't scale with anything, we'll classify its runtime as O(1): something that doesn't scale as other values change. With that in mind, we'll simplify our loop nest, as shown here: void amniscience(int n) { for (int i = 0; i < n; i++) { for (int j = 0; j < i; j++) { for (int k = 0; k < 106; k++) { cout << '*'; } } } } void amniscience(int n) { for (int i = 0; i < n; i++) { for (int j = 0; j < i; j++) { /************************* * Do O(1) work * * **********************/ } } } We're making progress! From here, let's look at what's now the innermost loop: for (int j = 0; j < i; j++) { /************************* * Do O(1) work * * **********************/ } How much work is done here? Each iteration of the loop does O(1) work, so we just need to figure out how many times the loop runs. Notice that the number of times this loop runs depends on the value of i from the outer loop. When i = 13, this will run 13 times. When i = 77, this will run 77 times. And more generally, this loop always runs exactly i times. Therefore, we'll say that it runs O(i) times - the number of loop iterations scales directly with the value of i. We have O(1) work per iteration, and O(i) total iterations, so this loop does O(i) work. It might seem weird to express the runtime here in terms of i rather than n, but that's actually perfectly fine. And in fact, it's more precise to do things this way, since the value of i changes as the code runs and this captures that in detail. That simplifies our code like this: void amniscience(int n) { for (int i = 0; i < n; i++) { for (int j = 0; j < i; j++) { /************************* * Do O(1) work * * **********************/ } } } void amniscience(int n) { for (int i = 0; i < n; i++) { /************************* * * * Do O(i) work * * * * **********************/ } } We're now left with one final loop, the one shown above. How should we analyze it? This section started with a discussion about what you're supposed to do when the amount of work done by each iteration of a loop isn't the same from iteration to iteration. And that's absolutely the case here. the iteration of this loop that happens when i = 1 is much faster than the iteration of the loop that happens when i = 1,000,000. We can't just multiply the number of iterations by the work done per iteration, since the work per iteration depends on which iteration we're on. Instead of doing that multiplication, instead, we can add up the work done by each iteration of the loop across all those iterations. Specifically, we can make the following reasonable approximations: When i = 0, this loop does "roughly" 0 units of work. When i = 1, this loop does "roughly" 1 unit of work. When i = 2, this loop does "roughly" 2 units of work. ... When i = n-1, this loop does "roughly" n-1 units of work. If we add up the work done across each iteration of the loop, we get (roughly) the following: 0 + 1 + 2 + 3 + 4 + 5 + ... + (n- 2) + (n- 1) units of work. That expression gives us the amount of work done, but it's a bit messy to work with. Can we simplify it! Indeed we can. You might remember from class that we worked out that 1 + 2 + 3 + ... + m = O(m^2). In our case, this means that 0 + 1 + 2 + 3 + 4 + 5 + ... + (n - 2) + (n - 1) = O((n - 1)^2) Of course, we aren't done yet. The expression O((n - 1)^2) is pretty messy. Remember - big-O notation likes to munch away smaller terms. We can clean this up by rewriting it like this: O((n - 1)^2) = O(n^2 - 2n + 1) = O(n^2) That last step follows because big-O notation only cares about the "biggest" of the terms in a sum, and here that biggest term is the n^2 term. This means that the loop does roughly 0 + 1 + 2 + ... + (n - 1) = O(n^2) work, and we can simplify our code one last time as follows: void amniscience(int n) { for (int i = 0; i < n; i++) { /************************* * * * Do O(i) work * * * * **********************/ } } void amniscience(int n) { /********************************* * * * * * Do O(n^2) work * * * * * ********************************/ } And so, overall, we see that the runtime is O(n^2). Let's do one more example. Consider the following piece of code: void avareed(int n) { for (int i = 0; i < n; i++) { if (i >= n / 4 && i < 3 * n / 4) { for (int j = 0; j < n; j++) { cout << '*'; } } else { cout << '?'; } } } This is a stranger piece of code than the ones we've seen before, but we can still use the techniques we've seen to figure out its runtime. We'll begin with the most deeply nested loop, which is this one here: for (int j = 0; j < n; j++) { cout << '*'; } That's a total of O(n) iterations, each of which does O(1) work, and so the runtime ends up being O(n). Feeding that back in and simplifying gives this: void avareed(int n) { for (int i = 0; i < n; i++) { if (i >= n / 4 && i < 3 * n / 4) { for (int j = 0; j < n; j++) { cout << '*'; } } else { cout << '?'; } } } void avareed(int n) { for (int i = 0; i < n; i++) { if (i >= n / 4 && i < 3 * n / 4) { /************************* * Do O(n) work * * **********************/ } else { cout << '?'; } } } We're now left with just one loop, but that loop is unusual. In some cases we take the top branch and do O(n) work. In some cases we take the bottom branch and do O(1) work. Indeed, to make that clearer, let's rewrite the else branch to show off how much work it does: void avareed(int n) { for (int i = 0; i < n; i++) { if (i >= n / 4 && i < 3 * n / 4) { for (int j = 0; j < n; j++) { cout << '*'; } } else { cout << '?'; } } } void avareed(int n) { for (int i = 0; i < n; i++) { if (i >= n / 4 && i < 3 * n / 4) { /************************* * Do O(n) work * ************************/ } else { /* Do O(1) work */ } } } So - what are we to make of this? We can't just multiply the number of loop iterations by the amount of work done per iteration, because the work done per iteration changes from iteration to iteration. Instead, let's take a step back and see if we can spot what the code is actually doing here. Notice that about half the time (when i is between 25% and 75% of n), an iteration does O(n) work. The other remaining half the time (when i isn't in this range), an iteration does O(1) work. What should we make of this? One insight that's helpful here is to split the work done into "easy" iterations of the loop and "hard" iterations of the loop. An "easy" iteration is one where we do O(1) work. A "hard" iteration is one where we do O(n) work. We therefore have that total work = (work done across "easy" iterations) + (work done across "hard" iterations). So let's solve for these individually. We know we'll do approximately = O(n) "easy" iterations, where we do O(1) work per iteration, so the total work for the easy iterations is O(n) O(1) = O(n). Similarly, we do roughly = O(n) "hard" iterations, each of which does O(n) work. That means that we do a total of O(n) O(n) = O(n^2) work across all the "hard" iterations. We therefore have that total work = O(n) + O(n^2) = O(n^2 + n) = O(n^2). That last step is there because big-O notation only keeps track of the biggest growth terms, and n^2 grows a lot faster than n. So our overall runtime here is O(n^2). Technique 3: Consult the Documentation The examples we've done so far here have worked mostly with integers, but most of the code you'll write in practice will work with containers like vectors, maps, sets, and the like. The good news is that the techniques for analyzing code written using those types is basically the same as for code that doesn't use them, with one big caveat: the cost of operations on container types isn't always what you might expect it to be. As an example, let's take this piece of code here: void grice(int m) { Set<int> values; for (int i = 0; i < m; i++) { values.add(i); } } How much work does this piece of code do, as a function of m? (I'm using m rather than n here for reasons that will become clearer in a bit.) Well, we can see that there are O(m) total iterations of the loop, and so as soon as we know how much work the loop itself does, we'll know the total amount of work done. So that then leads us to ask: how much work does the line values.add(i) do? To answer this, we'll head to the Stanford C++ Library Documentation website, which lists all of the costs of each operation in detail. If you visit the site and pull up information about the Set type, you'll see that the add method takes time O(log n), where n is the number of items in the set. In our case, this set never has more than m items in it, so each time we call add it does at most O(log m) work. Overall, this means that we have O(m) iterations, each of which does O(log m) work, and so the total work done here is O(m log m). This above example showcases how important it is to pull up the library documentation when working with container types. Over the rest of the quarter, we'll explore how these container types work, and you'll get a deeper, intuitive feel for why they have the runtime costs that they do. But in the meantime, make sure to consult the docs, because otherwise you won't be able to determine how much work is being done. Fun fact: one of the most common causes of slow code that we see in CS106B is accidentally using slow operations on container types without realizing it. Technique 4: Run Time Trials There's one final technique we'd like to mention for working out big-O runtimes: you can always just run the code, get some data points back, and make your best guess of the runtime! For example, suppose we have a function void whiphithichishi(int n); and run it on inputs of various sizes, producing this timetable: n = 1000 : 23.7935ms n = 2000 : 47.3231ms n = 3000 : 103.957ms n = 4000 : 184.809ms n = 5000 : 298.894ms n = 6000 : 434.666ms n = 7000 : 589.499ms n = 8000 : 764.828ms n = 9000 : 994.704ms n = 10000: 1236.59ms Given just this data, let's make a reasonable estimate of the big-O runtime of whiphithichishi. It's helpful to start off by comparing the ratios of runtimes here as the size of the input doubles. For example, notice that doubling the input size from 5,000 to 10,000 raises the runtime from 298.894ms to 1236.59ms, scaling by a factor of about 4.13. Doubling the input size from 2,000 to 4,000 grows the runtime from 47.3231ms to 184.809ms, a factor of about 3.9. And doubling the input size from 3,000 to 6,000 increases the runtime from 103.957ms to 434.666ms, a factor of about 4.18. So, generally speaking here, it looks like we're seeing that doubling the input size is increasing the runtime by roughly a factor of 4. Sometimes it's a bit lower than 4, sometimes it's a bit higher than 4, but we're generally orbiting around a factor of 4 here. So we can ask - what runtime has the property that if you double the input size, you the output size? That's the telltale sign of a quadratic growth rate, and so a reasonable guess for the runtime of this function is O(n^2). Of course, that's just a guess of the runtime. We can't be guaranteed that the runtime is exactly O(n^2), since we haven't seen the code. And indeed, this guess is actually wrong. The code that I wrote that generated these numbers is shown here: void whiphithichishi(int n) { Set<int> values; for (int i = 0; i < 2 * n; i++) { for (int j = 0; j < 3 * i; j++) { values.add(6 * n * i + j); } } } If you do a precise analysis of the runtime of this code, you'll find that it's O(n^2 log n). That's pretty close to O(n^2), but the extra log n factor means that it grows ever so slightly faster than O(n^2). This might account for why the ratios we saw were generally skewing a little bit higher than a factor of 4, but, then again, that could also just be random noise. But, with that being said, an empirical runtime analysis is a great way to get a quick check on a hypothesis or to otherwise get something in the ballpark of the overall answer. Just remember that when doing a purely empirical analysis you might miss a log factor here or there - or perhaps miss some other slowlygrowing terms.
https://cs106b.stanford.edu/citation
At the end of the quarter, we run analytic software over all CS106B submissions to find sections of student-submitted code that have been copied from elsewhere rather than independently written by the student. A staffer then reviews the situation to determine appropriate followup. With a correct understanding of the authorship, we can ensure that credit is being awarded properly. Accurate attribution of code authorship is an important tenet of the programming community and of academic integrity in general. Before we start the scan, there is a window of opportunity where students may amend their submissions. Understanding that mistakes can happen, this provides a chance to make things right by correcting a misrepresentation of authorship and/or adding missing citations. Permissible assistance The course policy on collaboration and the Honor Code allows students to exchange ideas with others, but not to share or copy code. If you are in office hours or discussing the assignment with other students and a few lines of code are jointly sketched, it is fine to learn from those lines and incorporate them into your assignment. Your assignment might also take inspiration from a code example in lecture, section, or the textbook. Both of these situations are within the spirit of exchanging ideas, learning from others, but writing the code yourself. This help is entirely permissible, but please be sure to cite any direct influence. The code you submit is still distinctly your own and you retain full authorship; the citation simply acknowledges the work of others that influenced your code. Unpermissible assistance In contrast, an honor code violation looks more like having access to solution code (such as code found on the Internet, written by another current or past student, or generated by an AI tool) and basing your submission off of it, whether reusing an exact copy or borrowing code sections from it and remixing. Submitting this code without citation is a misrepresentation of authorship and is a breach of academic integrity -code written by another is being passed off your own. This is unacceptable, and the CS department has become adept at identifying instances of misrepresented authorship using sophisticated tools. Unpermitted collaboration/partnership There is yet a third category where two current students work together and both submit the same/similar code based on the joint work. Submitting such work as your own without acknowledging the contributions of another is also a misrepresentation of authorship. If you have mistakenly engaged in a disallowed partnership, we offer you the option to provide a retroactive citation of that collaboration. This citation opens the path to a resolution where we work with you to establish a fair attribution of authorship, and adjust allocated credit accordingly. Making a retroactive citation Below we identify three categories of assistance that could apply to your code. The vast majority of student work falls into Type 0, for which there is no need for any followup. Code of Type 1 or Type 2 that is absent citation is this concern we would like to address at this time. Type 0: Either no assistance or assistance that does not require citation This code was my original work, authored by me independently. This code was not derived from nor influenced by code developed by others. I brought this code to LaIR/office hours and a member of the course staff helped me debug and understand my code. This code was taken from published CS106B materials from this quarter such lectures, section, textbook, YEAH slides, etc. Type 1: Allowable assistance that requires citation When working on this code, I talked with a peer to conceptualize the task, brainstorm the design, or talk through the approach to problem-solving. We never shared/read/wrote actual code, but did talk about ideas and strategies at a high-level. Our code may look similar in broad terms. Type 2: Assistance that is not allowed I exchanged solution code with a peer or former student (either as giver or receiver). I jointly developed this code with a peer. I found and read solution code online and it influenced the code I wrote. I requested help from a tutor, online forum, paid service, AI model, etc. and received code/help that influenced the code I wrote. I gave or received aid on the midterm or final exams. If upon reflection, you believe that some portion of your work should be amended to acknowledge assistance of Type 1 or Type 2 , you may submit a retroactive citation using this form. There are a number of possible outcomes in response: If the retroactive citation cites permissible help, your citation acknowledges that contribution and corrects the previous oversight. There is no further action to take. If the retroactive citation cites use of work of another as your own, we would not be able to award you credit for that work. We would discount/zero the score to reflect your diminished contribution. If the retroactive citation cites work done in collaboration with another student, we will follow up to understand the extent of the collaboration and adjust grading credit to reflect an appropriate division of work and authorship. In all of the above, if the retroactive citation corrects the previous misrepresentation of authorship, there is no longer an Honor Code violation and there is no followup with the judicial office. If you are not sure of how to proceed, please reach out to Sean, Julie, or Clinton. We very much appreciate those of you who want to do the right thing, and we will meet for a constructive, non-judgmental review of what has happened and what is the best way forward.
https://cs106b.stanford.edu/course_placement
Not sure of CS106B is right for you? Wondering if you should start with CS106A or CS107 instead? This is a collection of our usual advice to students who ask about selecting the course that's right for them. Of course, we are happy to provide further guidance, just reach out on the forum or in office hours. CS106A: Start here! CS106A is our first-quarter programming course. It teaches the widely-used Python programming language, with an emphasis on conceptual understanding of the fundamental building blocks of coding (in any language) and principles of good coding style. If you're interested in learning how to program a computer, this is the place to start. CS106A has no prerequisites - it's open to everyone! The course is designed to appeal to everyone from humanists and social scientists to aspiring hard-core techies. If you've had some experience with coding, it can be hard to decide if CS106A or CS106B is the right starting point for you. If you've taken AP CS Principles (but not AP CS A / Java), we recommend that you start with CS106A. If you completed AP CS A, then CS106B is most likely the best match for you, although some students who feel unsatisfied with their high school AP CS A experience do start with CS106A. We recommend that you take CS106A if You are interested in learning the first fundamentals of how to program computers. We recommend that you not take CS106A if You have prior programming experience at a level comparable to an introductory college course (for example, if you scored a 4 or 5 on the AP CS A / Java exam). You have significant prior programming experience and just want to learn Python as a second+ programming language. We sometimes hear that students are concerned that starting in CS106A means being too far "behind" their peers to successfully complete a CS major, but this is not true at all. Nearly half of the CS department's bachelor's degree graduates each June got their start in CS106A, so you'll be in good company! In the 2023-24 academic year, CS106A is offered every quarter. Visit the CS106A website. CS106B: Next step CS106B is our second course in computer programming. It focuses on techniques for solving more complex problems than those covered in CS106A and for analyzing program efficiency. Specifically, it explores fundamental data types and data structures, recursive problem solving, and basic algorithmic analysis. It's taught in C++, but the focus is on conceptual understanding of algorithms. If you'd like a focused study of C++ the language itself, consider taking CS106L. CS106B assumes you have programming experience at the level of CS106A, though you don't necessarily have to have taken our CS106A course. If you are experienced with basic control structures (conditions, loops), variables, arrays/lists, maps, and program decomposition, then you should be ready to take CS106B. If you've had some experience with coding, it can be hard to decide if CS106A or CS106B is the right starting point for you. If you've taken AP CS Principles (but not AP CS A / Java), we recommend that you start with CS106A. If you completed AP CS A, then CS106B is most likely the best match for you, although some students who feel unsatisfied with their high school AP CS A experience do start with CS106A. We recommend that you take CS106B if You have prior programming experience at the level of CS106A. You are interested in learning more about problem-solving with computers. You've programmed before but have not seen recursion, data structures, or algorithmic analysis. We recommend that you not take CS106B if You already have completed equivalent coursework elsewhere. You have taken AP CS Principles, but not AP CS A / Java. In the 2023-2024 academic year, CS106B is offered every quarter. Visit the CS106B website. Optional add-ons to CS106B We offer several courses that are designed to complement CS106B with additional material. None of these courses are required, and they do not count toward the CS major or CS minor requirements. However, if you're interested in going deeper for your own enrichment, you may find them worth checking out! Additional foundation support: CS100B CS100B is an optional 1-unit companion course to CS106B that provides extra support to students from under-resourced backgrounds. It meets for an additional weekly section where students receive access to additional mentoring, in depth content review, and other study resources. It is part of the Pathfinders/ACE program jointly sponsored by the CS department and the School of Engineering. Enrollment is by application, read more at https://engineering.stanford.edu/students-academics/equity-and-inclusion-initiatives/undergraduate-programs/additional-calculus We accept applications from all students who believe they may benefit from participating in small active-learning sessions led by a highly trained graduate student. C++ Language: CS106L CS106L is an optional 1-unit companion course to CS106B that focuses purely on the C++ programming language. Unlike CS106A and CS106B, which focus more on general programming skills and fundamental programming concepts, CS106L is specifically designed to focus on language features particular to C++ and how to use the C++ programming language to solve problems. Although CS106L is designed as a companion course to CS106B, it's open to anyone with a comparable background. We recommend that you take CS106L if You have prior programming experience at the level of CS106B (or are currently enrolled.) You are interested in learning more about the C++ programming language and the standard libraries. You are willing to put in more work than is necessary for CS106B. We recommend that you not take CS106L if You want a deeper understanding of topics like recursion, data structures, or big-O notation. You want to learn programming at the level of CS106B, but don't have the time to take those courses. In the 2023-2024 academic year, CS106L is offered in Autumn, Winter, and Spring quarters. Visit the CS106L website. More adventures: CS106M CS106M is an optional 1 unit add-on course to CS106B that explores supplemental material in a small discussion setting. For example, this year's offering will likely cover topics like data compression, error-correcting codes, and digital signatures. The topics covered in CS106M will not be required by later CS courses, even if you are planning to major in CS. We recommend that you take CS106M in addition to CS106B if: You are currently enrolled in CS106B. You are interested in exploring additional topics and deepening your study of the course material in a small discussion setting. You are willing to put in more work than is necessary for CS106B. We recommend that you not take CS106M if You are concerned that you "need" to take CS106M to avoid falling behind everyone else. In the 2023-2024 academic year, CS106M is offered only in Fall quarter. Social Good: CS106S CS106S is an optional 1 unit add-on course to CS106B that gives you a chance to work on programs for social good. The class brings in student groups, nonprofits, and local tech companies and is a mix of a speaker series and small project course. The course also teaches basic web development, but is not meant to be a stand-alone web development course. We recommend that you take CS106S in addition to CS106B if You are interested in exploring social good applications of computer science. You are willing to put in more work than is necessary for CS106B. In the 2023-2024 academic year, CS106S is offered in Autumn, Winter, and Spring quarters. Visit the CS106S website. Can I skip the intro courses altogether? Many students entering Stanford today have had considerable programming experience in high school or from their own independent work with computers. If you are in that position, the idea of starting with a beginning programming course-even an intensive one like CS106B-seems like a waste of time. Your perception may in fact be correct. In our experience, there are somewhere between 10 and 15 students in each entering class who should start at a more advanced point in the sequence. Below we talk about some of these more advanced classes (CS107 and CS107E). For most of you, however, the right place to start is with the CS106 series. Most high-school computing courses are somewhat weak and provide little background in modern software engineering techniques. By taking CS106, you will learn how the CS department at Stanford approaches programming and get a solid foundation for more advanced work. If you're unsure where you should start the programming sequence, please talk with us. CS107: How it all works After completing the intro programming sequence, CS107 takes you under the hood to learn the ins and outs of computer systems. It explores how high-level programming constructs are represented internally inside the computer and how those internal representations affect program behavior and performance. Along the way, it provides programming maturity and exposure to developing software in a Unix environment. CS107 has CS106B as a prerequisite and assumes an understanding of fundamental programming techniques and good programming style. As a result, it's rare for incoming students to jump directly into CS107 and to skip the CS106 series entirely. Typically, we'd only recommend this to students with a background comparable to CS106A/B and who already have good programming style. Most students, even those who go on to be CS majors, usually begin in the CS106 sequence. We recommend that you take CS107 if You have completed CS106B or have the equivalent programming background, including familiarity with recursion and fundamental data structures (binary trees, dynamic arrays, linked lists, graphs, etc.) You have experience writing readable code - writing comments, decomposing problems into smaller pieces, etc. We recommend that you not take CS107 if You have never before taken a class in computer programming. You have prior programming experience but have not met the postconditions of CS106B. Visit the CS107 website. CS107E: How it works, embedded CS107E is version of CS107 that covers similar topics but which focuses on programming a small computer that can easily fit into the palm of your hand. The class is smaller and more project-oriented than CS107 and lets you play around with small embedded devices to see how low-level systems concepts directly let you control physical devices. The CS107E FAQ offers perspective on advice on choosing between 107 and 107E. We recommend that you take CS107E if You meet all the requirements for CS107. You enjoy working on open-ended projects. We recommend that you not take CS107E if You're nervous about taking CS107 and want to satisfy that requirement in a different way. Visit the CS107E website.
https://cs106b.stanford.edu/assignments/2-adt/ethics.html
Thus far in CS106B, you have been introduced to the technique of benchmarking (i.e., measuring run time) and saw in your first assignment how the choice of algorithm can have significant impacts on performance. Next week, we will expand and formalize our accounting of algorithmic performance using a technique called Big-O analysis, which will inform our study of algorithms throughout the rest of the course. However, we want to approach the topic of efficiency and optimization with a certain amount of cautious skepticism in terms of its ethical implications. A company might argue that as computers become increasingly more powerful, an effort to make a program slightly more efficient or use a bit less memory does not warrant the investment of (expensive) programmer time, but is the corporate bottom line the only cost to consider? What about the savings of environmental and energy resources? (I'm looking at you, cryptocurrency mining, and the vast amount of squandered computer cycles) On the other hand, prioritizing efficiency at the cost of sacrifices in effectiveness, quality, or ease of use seems a poor tradeoff of a different sort. This short ethical reflection is designed to prepare you to learn about Big-O by pausing to consider some of these challenges. Q8. In a short paragraph, describe a real or plausible scenario in which reworking an algorithm to improve its efficiency might benefit Earth's environment or humanity as a whole. Include your thoughts on how a software engineer working on this piece of code might identify such potential benefits and take them into consideration when designing the code. As ethical and socially-conscious computer programmers, we also know that many considerations other than the speed and memory use are important in choosing the appropriate algorithm for a particular use. Dr. Gillian Smith, an associate professor at the Worcester Polytechnic Institute, identifies an interesting fallacy that computer scientists often fall into when applying algorithmic analysis techniques like benchmarking and Big-O analysis: If it's more efficient, it's better. The quality of a program, independent of how people interact with it, should be evaluated only with respect to how well it minimizes cost. The following case study illustrates the importance of supplementing efficiency and performance analyses with human-centric evaluation. In 2006 the state of Indiana awarded IBM a contract for more than $1 billion to modernize Indiana's welfare case management system and manage and process the State's applications for food stamps, Medicaid and other welfare benefits for its residents. The program sought to increase efficiency and reduce fraud by moving to an automated case management process. After only 19 months into the relationship, while still in the transition period, it became clear to Indiana that the relationship was not going as planned. In particular here are some "lowlights" of the system's failures to provide important and necessary services for those in need: "Applicants waited 20 or 30 minutes on hold, only to be denied benefits for 'failure to cooperate in establishing eligibility' if they were unable to receive a callback after having burned through their limited cellphone minutes." "Applicants faxed millions of pages of photocopied driver's licenses, Social Security cards, and other supporting documents to a processing center in Marion, Indiana; so many of the documents disappeared that advocates started calling it "the black hole in Marion" [...] Any application missing just one of tens to hundreds of pieces of necessary information or paperwork were automatically denied." "By February 2008, the number of households receiving food stamps in Delaware County, which includes Muncie, Indiana, dropped more than 7 percent, though requests for food assistance had climbed 4 percent in Indiana overall." (Quotations from Virginia Eubanks) In light of these failures, the State of Indiana cancelled its contract with IBM and sued the company for breach of contract, stating that the company had failed to deliver a system that helped people get the services they needed. In court, IBM argued that they were not responsible for issues related to wait times, appeals, wrongful denials, lost documents, etc. as the contract only stated that a successful system would succeed by reducing costs and fraud. IBM's system did reduce costs, but did so by denying people the benefits they needed. In light of this, we would like you to consider the following questions: Q9. According to the contract that IBM struck with the state of Indiana, the criteria for optimization were improving efficiency of the overall welfare system and reducing fraud. Criteria for reducing wait times and wrongful denials were not included. However, wrongfully denying benefits has a huge negative impact on the citizens who rely on the system. If criteria like minimizing wrongful denials were not included in the contract, should engineers have included them in their optimization algorithm? Why or why not? Q10. Imagine that after completing CS106B you are hired at IBM as an engineer working on this system. How might you have approached designing and setting the goals of this system? How might you apply algorithmic analysis tools to build a system that achieved the desired goals? Could you do so in a way that avoids the severe negative impacts on users of the system that are outlined in the case study? References If you are interested to learn more, we highly recommend reading more from Virginia Eubanks. Virginia Eubanks, "Want to Cut Welfare? There's an App for That.", The Nation, May 27, 2015. https://www.thenation.com/article/archive/want-cut-welfare-theres-app/ Virginia Eubanks, "Automating Inequality: How High-Tech Tools Profile, Police, and Punish the Poor", Macmillan, 2018. https://us.macmillan.com/books/9781250074317/automatinginequality
https://cs106b.stanford.edu/faq
Are you a student looking for information about how the course will be structured in Winter Quarter 2024? You're in the right place! Are lectures recorded? Is attendance required? Lectures meet MWF 11:30 AM - 12:20 PM in Hewlett 200. We encourage you to join us in person, but recordings will also be posted to Canvas for later asynchronous viewing. We very much encourage live attendance but do not require it. Read more about lectures. How will sections work? Is attendance required? Each of you will be assigned to a small group section that meets weekly. Section participation is expected and contributes to your course grade. Note the section times listed in Axess are not accurate. Section times will be arranged in the first week of the quarter. Read more about section. Will there be exams? Yes, at mid-quarter and end-quarter. Read more about exams. I am currently unable to enroll on Axess. How can I shop the course in the meantime? Canvas has recently enabled "course shopping", and we configured our Canvas site to be "open for shopping"; this allows you to access videos without enrolling. Note that you must be formally enrolled on Axess to submit work for grading. Do you allow auditors? Auditors are welcome to attend lecture, access website materials, and work on section and assignments on their own without submitting. We will not be able to grade work from auditors, nor can auditors be accommodated in sections, helper hours, or the online forum. How do I choose which of the intro courses is right for me? Most incoming students find the right place by starting in either CS106A or CS106B, or, more rarely, in CS107. You may also want to consider adding on one of the CS106B companion courses, CS100B, CS106L, and CS106M. Read more about the options in our guide to course placement. Still have unanswered questions? Hop on over to the Ed discussion forum and ask! We're happy to help.
https://cs106b.stanford.edu/index.html
Course Overview and Welcome Welcome to CS106B: Programming Abstractions! This is the second course in our introductory programming sequence. The prerequisite, CS106A, establishes a solid foundation in programming methodology and problem-solving in Python. With that under your belt, CS106B will acquaint you with the C++ programming language and introduce advanced programming techniques such as recursion, algorithm analysis, and data abstraction, explore classic data structures and algorithms, and give you practice applying these tools to solving complex problems. We're excited to share this great material with you and have a superb team of section leaders that will support you through the challenges to come. We hope you will find the time worth your investment and that you enjoy your growing mastery of the art of programming! Teaching Team Instructor: Sean Head TA: Clinton We have an incredible group of undergraduate section leaders (SLs) who lead weekly sections and help students 1-on-1 in LaIR hours. Read more about the teaching team and office/LaIR hours. Adarsh Alex Andrew Anshika Anushree Arisa Ben Benji Brandon Bryant Butch Cathy Claire Elena Ellie Everett Febie Gunnar Haven Iris Jack Jacob Javokhir Jenny Jessica Jesus Jonathan Joshua Justin Kate Keely Kenneth Kenny L'Hussen Lauren Naama Naomi Nathan Ngoc Noah Osose Ramya Renn Richard Sachin Tom Ty Usman Valerie Young Course Topics Overview of Main Topics Our planned curriculum will cover the following topics in this approximate order: C++ basics Data abstraction, classic ADTs Recursion and backtracking Classes and object-oriented programming Pointers and dynamic memory Linked data structures Advanced algorithms Learning Goals After completing CS106B, we hope you will have achieved the following learning goals: I am excited to use programming to solve real-world problems I encounter outside class. I recognize and understand common abstractions in computer science. I can identify programmatic concepts present in everyday technologies because I understand how computers process and organize information. I can break down complex problems into smaller subproblems by applying my algorithmic reasoning and recursive problem-solving skills. I can evaluate design tradeoffs when creating data structures and algorithms or utilizing them to implement technological solutions. We'll also be giving you tools to tackle the following questions (note that these don't have single right or wrong answers!): What is possible with technology and code? What isn't possible? How can I use programming to solve problems that I otherwise would not be able to? What makes for a "good" algorithm or data structure? Why? Which problems should I solve with algorithms and data structures? What does a responsible programmer do when using data about real people? Prerequisites The prerequisite for CS106B is completion of CS106A and readiness to move on to advanced programming topics. A comparable introductory programming course or experience (including high school AP courses) is often a reasonable substitute for Stanford's CS106A. If you are unsure if this course is the right for you, read more about course placement. Course Structure Lectures Lecture meets MWF 11:30 AM - 12:20 PM in Hewlett 200. Lecture recordings will be posted on Canvas for future review. All students are expected attend lectures in person if at all feasible (i.e., not if you are sick or an SCPD remote student), in order to fully participate in class discussions and other synchronous activities. We understand that this isn't possible for every student every time, so if you are unable to attend we ask that you at least watch the video of class before the next class, so you are up to speed on all course topics and important announcements. Read more about lectures. Note about recording consent: Video cameras are located in the back of the lecture room to capture the instructor presentation. These recordings might be reused in other Stanford courses, viewed by other Stanford students, faculty, or staff, or used for other education and research purposes. While the cameras are positioned with the intention of recording only the instructor, occasionally a part of your image or voice might be incidentally captured. If you have questions, please contact a member of the teaching team. Sections Each students is assigned to a weekly small group discussion section, led by an undergraduate section leader. Your section leader is your mentor, grader, and personal connection to the greater CS106B course staff. Sections begin the second week of classes, and attendance and participation are mandatory for all students. Your section leader will evaluate your section participation; this contributes to your course grade. Read more about section. Assignments There will be regular assignments, about one per week. An assignment may include written problems, hands-on exercises with the tools, coding tasks and/or a larger complete program. Assignments are to be completed individually. Programs are graded on "functionality" (is the program's behavior correct?) and "style" (is the code well-written and designed cleanly?). We use a bucket grading scale to focus attention on the qualitative rather than quantitative feedback. Read more about assignments, grading, and late policy. Exams We have mid-quarter and end-quarter exams. The mid-quarter is a check-in to assess your understanding of core topics covered in the first half of the course and help you chart a path forward. The final is a comprehensive assessment of your mastery of the course learning goals. Mark these dates in your calendar now! Midterm: Thursday, February 15, 7:00 - 9:00 PM Final: Monday, March 18, 8:30 - 11:30 AM Read more about exams. Course Grades Final grades for the course will be determined using the following weights: 53% Programming assignments 15% Mid-quarter exam 25% End-quarter final exam 5% Section participation 2% Quiz 0 on canvas In order to receive a passing grade in the course, you must earn a passing grade on the programming assignments as well as (collectively) the exams (i.e., failing an exam will not disqualify you from passing the course, as long as your average across both exams is a passing grade). So, someone who has a passing exam average but a failing average on the programming assignments, or vice versa, will not receive a passing grade in the course. Units If you are an undergraduate, you must enroll in CS106B for 5 units (this is by department and university policy, no exceptions). If you are a graduate student, you may enroll in CS106B for 3 or 4 units to reduce your units for administrative reasons. Taking the course for reduced units has no change on the course workload. Incompletes The university "I" grade ("incomplete") is sometimes appropriate for circumstances of significant personal or family emergency disruption that occur late in the quarter and prevent a student from finishing course requirements on schedule. In order to be eligible for an Incomplete, University policy stipulates that a student must have completed a "substantial" part of the course work in "satisfactory" fashion. There must also be extenuating circumstances that warrant an extension of time beyond the end of the quarter to complete the remaining work. Approval for an incomplete is at the instructors' discretion. Incompletes are not be considered for reasons such as poor performance in the course or over-commitment. Withdrawal from the course is more appropriate in those cases. Honor Code As a student taking a Stanford course, you agree to abide by the Stanford Honor Code, and we expect you to read over and follow our specific CS106B Honor Code policy. The work you submit for grading must be your own original, independent effort and must not be based on, guided by, or jointly developed with the work of others. The CS department employs powerful automated plagiarism detection tools that compare assignment submissions with other submissions from the current and previous quarters, as well as related online resources. The tools also analyze your intermediate work, and we will run the tools on every assignment you submit. The vast majority of you are here to learn and will do honest work for an honest grade. We celebrate and honor your commitment. Because it's important that all cases of academic dishonesty are identified for the sake of those playing by the rules, we will refer all cases of concern to the Office of Community Standards. Course Resources Textbook Roberts, Eric. Programming Abstractions in C++. ISBN 978-0133454840. You can find different options to access the textbook here . Recommended readings for each lecture will be posted on our lecture schedule. Software The official CS106 programming environment is Qt Creator, which is an editor bundled with C++ compiler and libraries. The software runs on Windows, Mac, and Linux and is free for personal/student use. The Qt Installation Guide has instructions for installing the tools onto your computer. Getting help We want to enable everyone to succeed in this course and offer different paths to help. The instructors and Head TA will hold weekly office hours. The section leaders staff LaIR helper hours. The CS106B Ed Discussion forum allows public Q&A and discussion with your peers. Here is the Quick Start Guide to using Ed. Accommodations Students who need an academic accommodation based on the impact of a disability should initiate a request with the Office of Accessible Education. Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter dated in the current quarter. Students should contact the OAE as soon as possible since timely notice is needed to coordinate accommodations. The OAE has contact information on their web page: http://oae.stanford.edu. Once you obtain your OAE letter, please send it to the head TA. Course Tools The central place for CS106B resources is the course website right here at https://cs106b.stanford.edu. The website is your go-to for course materials (lectures, assignments, sections, exams) and course policies and information. We also make use use these additional tools: Canvas to publish lecture videos and lecture quizzes. Ed Discussion forum for online community, Q&A, and posted announcements. Paperless, our custom site for submitting assignments and viewing grading feedback. LaIR, our custom tool for mananging the queue in helper hours. Gradescope, for viewing graded exams.
https://cs106b.stanford.edu/honor_code
Since 1921, academic conduct for students at Stanford has been governed by the Honor Code, which reads as follows: THE STANFORD UNIVERSITY HONOR CODE, 2023 The Honor Code is an undertaking of the Stanford academic community, individually and collectively. Its purpose is to uphold a culture of academic honesty. Students will support this culture of academic honesty by neither giving nor accepting unpermitted academic aid in any work that serves as a component of grading or evaluation, including assignments, examinations, and research. Instructors will support this culture of academic honesty by providing clear guidance, both in their course syllabi and in response to student questions, on what constitutes permitted and unpermitted aid. Instructors will also not take unusual or unreasonable precautions to prevent academic dishonesty. Students and instructors will also cultivate an environment conducive to academic integrity. While instructors alone set academic requirements, the Honor Code is a community undertaking that requires students and instructors to work together to ensure conditions that support academic integrity The purpose of this handout is to make our expectations as clear as possible regarding the Honor Code. The basic principle under which we operate is that you are expected to submit your own work in this course. Claiming independent authorship for work that was derived in whole or in part from the work of others constitutes plagiarism, which is a serious violation of basic academic standards. Under the Honor Code you are obligated to follow all of the following rules in this course: Rule 1: You must not look at assignment solutions that are not your own. It is an act of plagiarism to take work that is copied or derived from the work of others and submit it as your own. For example, using a solution from the Internet, a solution from another student (past or present), a solution taken from an answer set released in past quarters, or some other source, in part or in whole, that is not your own work is a violation of the Honor Code. Many Honor Code infractions we see make use of past solution sets. The best way to steer clear of this possibility is simply to not search for solutions to the assignments. Moreover, looking at someone else's solution in order to determine how to solve the problem yourself is also an infraction of the Honor Code. In essence, you should not be looking at someone else's answers in order to solve the problems in this class. This is not an appropriate way to "check your work," "get a hint," or "see alternative approaches." Additionally, you must not solicit solutions from anyone, animate or inanimate. For example, it is a violation of the Stanford Honor Code to ask another student to share their answers with you, to ask a tutor to provide other students' solutions to you, to request solutions on sites like Stack Overflow or Chegg, or to prompt an AI tool to generate solution code. Rule 2: You must not share your solutions with other students. In particular, you should not ask anyone to give you a copy of their answers or, conversely, give your answers to another student. Similarly, you should not discuss your solution strategies to such an extent that you and your collaborators end up turning in the same answers. Moreover, you are expected to take reasonable measures to maintain the privacy of your solutions. For example, you should not leave copies of your work on public computers nor post your solutions on a public website. Rule 3: You must properly cite any assistance you received. If you received aid from a person/resource external to the course staff or course materials, you must cite from whom you received help and what specific help you received. A proper citation should specifically identify the source (e.g., person's name, book title, website URL, etc.) and a clear indication of how this assistance influenced your work. For example, you might write "Student X mentioned the idea of having the base case be Y and the recursive step work in way Z." If you make use of such assistance without giving proper credit - or, if you provide a misleading or inaccurate statement describing the help you received - you may be guilty of plagiarism. It is also important to make sure that the assistance you receive consists of general advice that does not cross the boundary into having someone else write the actual solutions or show you their solutions. It is fine to discuss ideas and strategies, but you should be careful to write your solutions on your own, as indicated in Rules 1 and 2. If you are working with a tutor, be sure they/you are following the rules for the Honor Code as it applies to tutors and use of tutoring tools. Rule 4: You may only reuse past work in certain, limited situations. We tend to reuse assignments from quarter to quarter. Following the general principle that the names affixed to a submission should accurately represent its authorship, you may only resubmit work from prior quarters provided that the exact same set of people who initially turned in the assignment resubmit. This means, in particular, that if you completed an assignment individually in a previous quarter, you may only resubmit that assignment if you do so individually; and if you completed an assignment with a partner in a previous quarter, you may only resubmit that assignment if you submit with that exact same partner. To elaborate on that last point, if you worked with a partner in a previous quarter, you are retaking the course or resolving an incomplete, and your partner is not also retaking the class or resolving an incomplete, you may not resubmit the past work you did on that assignment in any circumstance. The policies above apply equally to reading, copying, or adapting solutions you submitted in previous quarters. For example, if you submitted an assignment individually in a previous quarter, you should not refer to your submission on that assignment if you are planning on redoing the assignment in a pair. Similarly, if in a previous quarter you worked with a partner who is not retaking the class, you must not reread or copy anything from that previous submission in the course of redoing the assignment. Rule 5: Use of generative AI tools is disallowed on graded work While artificial intelligence (AI) tools can be valuable in certain contexts, in this course it is important that students develop their own skills to create, modify, and debug code without the use of this technology. To maximally gain from the intentionally designed learning experiences in the course, it will be crucial that that students rely on personal efforts rather than use of AI tools. In fact, in many cases, it will be the effort itself (not the product) that is most valuable! For this class, all code submitted for a grade must be independently written by you. Just as you cannot take credit for using code written by others, you are disallowed from using generative AI tools (like ChatGPT) to create, modify, or debug code which you then submit as your own work. Doing so in this course is a violation of the Stanford Honor Code. Note: all submissions are subject to automated plagiarism detection. The Stanford CS department employs powerful automated plagiarism detection tools that compare assignment submissions with other submissions from current and previous quarters, including intermediate versions. The tools also compare submissions against a wide variety of online solutions and code produced by generative AI. These detection tools are effective at identifying unusual resemblances in programs, which are then further examined by the course staff. The staff then make the determination as to whether submissions are deemed to be potential infractions of the Honor Code and referred to Stanford's Community Standards office.
https://cs106b.stanford.edu/section/section1/
This week's section exercises focuses on exploring some C++ quirks and learning about some basic data structures. Have fun! Each week, we will also be releasing a Qt Creator project containing starter code and testing infrastructure for that week's section problems. When a problem name is followed by the name of a .cpp file, that means you can practice writing the code for that problem in the named file of the Qt Creator project. Here is the zip of the section starter code: Starter project 1) Program analysis: C++isms you should know Topics: Types, References, range based loops, strings, stanford C++ library In the following, we will analyze a simple program that filters last names whose end match a specific substring. Given an input string of format: name1,name2, ... and a string suffix, the program returns all the names in the input string that ends with the suffix. #include "SimpleTest.h" #include "vector.h" #include "strlib.h" using namespace std; /* @param input: input string whose last names will be filtered @param suffix: the substring which we will filter last names by Functionality: this function filters the input string and returns last names that end with 'suffix' */ Vector<string> filter(string input, string suffix) { Vector<string> filteredNames; Vector<string> names = stringSplit(input, ','); for (string name: names) { // convert to lowercase so we can easily compare the strings if (endsWith(toLowerCase(name), toLowerCase(suffix))) { filteredNames.add(name); } } return filteredNames; } STUDENT_TEST("Filter names") { Vector<string> results = filter("Zelenski,Szumlanski,Kwarteng", "Ski"); EXPECT_EQUAL(results, {"Zelenski","Szumlanski"}); results = filter("AmbaTi,Szumlanski,Tadimeti", "TI"); Vector<string> expected = {"AmbaTi", "Tadimeti"}; EXPECT(results == expected); results = filter("Zelenski,Szumlanski,Kwarteng", "NnG"); EXPECT_EQUAL(results, {}); // what other tests could you add? } 2) countNumbers (sum.cpp) Topics: Vectors, strings, file reading, while true, conditional statements, Stanford C+++ library The function countNumbers reads a text file and returns the number of times a user entered number appears in that text file. Here are some library functions that will be useful for this task: readLines, to read all lines from a file stream into a Vector stringSplit, to divide a string into tokens getLine, to read a line of text entered by the user stringIsInteger, to confirm a string of digits is valid integer In particular you will be asked to write the following function int countNumbers(string filename) When given the following file, named numbers.txt, as input, your function should print 1 when a user enters 42. Similarly, when the user enters 9, your function should return 2. 42 is the Answer to the Ultimate Question of Life, the Universe, and Everything This is a negative number: -9 Welcome to CS106B! I want to own 9 cats and 9 dogs. Solution /* * Function: countNumbers * ---------------------- * Write a program to read through a given file and count the * the number of times a user inputed number appears in that file. You * can assume that numbers will be composed entirely of numerical digits, * optionally preceded by a single negative sign. */ void countNumbers(string filepath) { ifstream in; if (!openFile(in, filepath)) { return; } Vector<string> lines = readLines(in); while (true) { string number = getLine("Enter a number to check (enter to quit): "); if (number == "") { break; } if (!stringIsInteger(number)) { cout << "Please enter a number" <<endl; continue; } int count = 0; for (string line : lines) { Vector<string> tokens = stringSplit(line, " "); for (string t : tokens) { if (t == number) { count ++; } } } cout << "Number " << number << " appeared " << count << " times in the file." << endl; } } 3) Debugging Deduplicating (deduplicate.cpp) Topics: Vector, strings, debugging Consider the following incorrect C++ function, which accepts as input a Vector<string> and tries to modify it by removing adjacent duplicate elements: void deduplicate(Vector<string> vec) { for (int i = 0; i < vec.size(); i++) { if (vec[i] == vec[i + 1]) { vec.remove(i); } } } The intent behind this function is that we could do something like this: Vector<string> hiddenFigures = { "Katherine Johnson", "Katherine Johnson", "Katherine Johnson", "Mary Jackson", "Dorothy Vaughan", "Dorothy Vaughan" }; deduplicate(hiddenFigures); // hiddenFigures = ["Katherine Johnson", "Mary Jackson", "Dorothy Vaughan"] The problem is that the above implementation of deduplicate does not work correctly. In particular, it contains three bugs. First, find these bugs by writing test cases that pinpoint potentially erroneous situations in which the provided code might fail, then explain what the problems are, and finally fix those errors in code. Solution There are three errors here: Calling .remove() on the Vector while iterating over it doesn't work particularly nicely. Specifically, if you remove the element at index i and then increment i in the for loop, you'll skip over the element that shifted into the position you were previously in. There's an off-by-one error here: when i = vec.size() - 1, the indexing vec[i + 1] reads off the end of the Vector. The Vector is passed in by value, not by reference, so none of the changes made to it will persist to the caller. Here are corrected versions of the code: // solution 1 void deduplicate(Vector<string>& vec) { for (int i = 0; i < vec.size() - 1; ) { if (vec[i] == vec[i + 1]) { vec.remove(i); } else { i++; } } } // solution 2 void deduplicate(Vector<string>& vec) { for (int i = vec.size() - 1; i > 0; i--) { if (vec[i] == vec[i - 1]) { vec.remove(i); } } } 4) Grid Basics (grid.cpp) Topic: Grids Write a function names maxRow that takes a grid of non-negative integers(numbers from 0 to infinity) and an in-bounds grid location and returns the maximum value in the row of that grid location. Solution // solution1 (manally loop through the row in the grid) int maxRow(Grid<int>& grid, GridLocation loc) { int max = -1; for (int col = 0; col < grid.numCols(); col ++) { if (grid[loc.row][col] > max) { max = grid[loc.row][col]; } } return max; } // solution2(use GridLocationRange) int maxRow(Grid<int>& grid, GridLocation loc) { int max = -1; int endCol = grid.numCols() - 1; for (GridLocation cell : GridLocationRange(loc.row, 0, loc.row, endCol)) { if (grid[cell] > max) { max = grid[cell]; } } return max; } *) Setting up your environment correctly Topics: QT Creator Navigate to Recommended Qt settings and set all recommended settings suggested. You'll use Qt Creator for all assignments this quarter, so it's important that you use the best settings to make you more efficient. Make a CS106B folder in your home directory. You can do so by: Opening your finder(if you use a Mac) or Windows Explorer (if you use Windows) Click on MacintoshHD for Mac or Primary Drive (C:) for windows Click on Users Click your name Right click and make new folder. Name the folder with ordinary characters, no spaces, special characters or emojis When you download new assignments and section materials, be sure to store them here. This will make it so that Qt has all the permissions it needs to run your programs If you use a Mac Right click on this section's .pro file Select Get info Check that Qt Creator has been set as the default program to open .pro files. If not, choose Qt Creator from the drop down, and click on Change All If you use Windows Open File Explorer (open any folder). Click the View tab. Select "File name extension" This will make it so you can see which files end with .pro Helpful Qt Creator hot keys (if you use windows, replace Command with Ctrl): Command + B to build your program Command + R to run your program Command + Y to run in debug mode
https://cs106b.stanford.edu/section/section2/
This week's section exercises explore ADTs!. By the end of this week, you'll be well-versed in all kinds of ADTs we've learned about in class, and know the best use cases for each of them. Remember that every week we will also be releasing a Qt Creator project containing starter code and testing infrastructure for that week's section problems. When a problem name is followed by the name of a .cpp file, that means you can practice writing the code for that problem in the named file of the Qt Creator project. Here is the zip of the section starter code: Starter project 1) Grid Basics (grid.cpp) Topic: Grids a) Maximum of a Row in a Grid Write a function names maxRow that takes a grid of non-negative integers(numbers from 0 to infinity) and an in-bounds grid location and returns the maximum value in the row of that grid location. Solution // solution1 (manally loop through the row in the grid) int maxRow(Grid<int>& grid, GridLocation loc) { int max = -1; for (int col = 0; col < grid.numCols(); col ++) { if (grid[loc.row][col] > max) { max = grid[loc.row][col]; } } return max; } // solution2(use GridLocationRange) int maxRow(Grid<int>& grid, GridLocation loc) { int max = -1; int endCol = grid.numCols() - 1; for (GridLocation cell : GridLocationRange(loc.row, 0, loc.row, endCol)) { if (grid[cell] > max) { max = grid[cell]; } } return max; } b) Average value Write a function named avgNeighborhood that takes a grid and a grid location and returns the average of all the values in the neighborhood of the grid location. A neighborhood is defined as all cells in a grid that border the grid location in all four directions(N, S, E, W). If the average is not an integer, return a truncated average. Solution // solution1 (we put the 4 locations in a Vector and loop over them) int avgNeighborhood(Grid<int>& grid, GridLocation loc) { Vector<GridLocation> possibleLocations = { {loc.row - 1, loc.col}, // north {loc.row + 1, loc.col}, // south {loc.row, loc.col + 1}, // east {loc.row, loc.col - 1} // west }; int sum = 0; int numValidLocations = 0; for (GridLocation dir : possibleLocations) { if (grid.inBounds(dir)) { sum += grid[dir]; numValidLocations += 1; } } return sum / numValidLocations; } // solution2 (Don't do this please!! We manually get all 4 locations and sum them up) int avgNeighborhood(Grid<int>& grid, GridLocation loc) { int sum = 0; int numValidLocations = 0; GridLocation north {loc.row - 1, loc.col}; if (grid.inBounds(north)) { sum += grid[north]; numValidLocations += 1; } GridLocation south {loc.row + 1, loc.col}; if (grid.inBounds(south)) { sum += grid[south]; numValidLocations += 1; } GridLocation east {loc.row, loc.col + 1}; if (grid.inBounds(east)) { sum += grid[east]; numValidLocations += 1; } GridLocation west {loc.row, loc.col - 1}; if (grid.inBounds(west)) { sum += grid[west]; numValidLocations += 1; } return sum / numValidLocations; } 2) Stack vs Vector showdown Topic: Stacks, Vectors We will analyze a simple program that emulates a text editor. The program accepts input from a user which can be of two forms: ADD string: This adds a one word string into the text editor UNDO: This removes the most recently added string from the editor. When the user finishes providing input (by hitting ENTER), we print a string which represents the words in the text editor, in the order they were added. Example: If we receive user input like "ADD I", "ADD Love", "ADD 106A", "UNDO", "ADD 106B", the program prints out "I love 106B". int main() { Stack<string> words; while (true) { string command = getLine("Enter a command (press enter to quit): "); if (command == "") { break; } Vector<string> splitCommands = stringSplit(command, " "); if (splitCommands[0] == "ADD") { words.push(splitCommands[1]); } else if (splitCommands[0] == "UNDO") { words.pop(); } } string result; while (!words.isEmpty()) { result = words.pop() + result; } cout << result << endl; return 0; } 3) Maps Topic: Maps Here, we analyze a simple program that uses maps to count elements in a vector Map<string, int> countElements(Vector<string>& names) { Map<string, int> frequency; for (string name: names) { // When using the square bracket syntax([]), we don't need to initialize // names in the map before adding unto it. If name doesn't already exist // in the map, [] in the Stanford Map will initialize it for us. frequency[name] += 1; } return frequency; } 4) Friends (friendlist.cpp) Topic: Maps, Sets a) Building the friendList Write a function named friendList that takes in a file name, reads friend relationships from the file, and writes them to a Map. friendList should return the populated Map. Friendships are bi-directional, so if Abby is friends with Barney, Barney is friends with Abby. The file contains one friend relationship per line, with names separated by a single space. You do not have to worry about malformed entries. If an input file named buddies.txt looked like this: Barney Abby Abby Clyde Then the call of friendList("buddies.txt") should return a resulting map that looks like this: {"Abby":{"Barney", "Clyde"}, "Barney":{"Abby"}, "Clyde":{"Abby"}} Here is the function prototype you should implement: Map<string, Set<string> > friendList(String filename) Solution Map<string, Set<string> > friendList(string filename) { ifstream in; Vector<string> lines; if (openFile(in, filename)) { lines = readLines(in); } Map<string, Set<string> > friends; for (string line: lines) { Vector<string> people = stringSplit(line, " "); string s1 = people[0]; string s2 = people[1]; friends[s1] += s2; friends[s2] += s1; } return friends; } b) Finding common friends Write a function named mutualFriends that takes in the friendList you just built, and strings representing two friends, and returns the names of the mutual friends they have in common. Solution Set<string> mutualFriends(Map<string, Set<string> >& friendList, string friend1, string friend2) { return friendList[friend1] * friendList[friend2]; }
https://cs106b.stanford.edu/assignments/1-cpp/
Due Monday, January 22 at 11:59 PM Submit to Paperless. Deadline is 11:59 PM. The late day policy gives you the ability to self-grant an extension (as long as you have not used all your late days); we trust you will make reasonable and sparing use of this power. Be sure to reserve late days for emergencies. Reminder: You have a limited pool of late days. You have a total of 4 late days to use throughout the quarter, but you cannot use more than 2 late days per assignment. Late days are expended in 24-hour blocks. See the Assignments page for more details. Here it is - the first programming assignment of the quarter! This assignment is a mix of coding, testing, and debugging tasks that get you practicing with the C++ language and development tools. The code you are to write uses expressions, control structures, functions, and string processing. Your prerequisite work means you should be familiar with these concepts; the novelty comes in figuring how to take what you already know and translate into the curious new world of C++. You also will build familiarity with the development tools we use and be introduced to strategies for testing and debugging your code. By the time you've completed the assignment, you'll be more comfortable working in C++ and ready to start building larger projects, or as we like to say, you'll have gotten your C++ legs under you! (apologies for the bad pun...) This assignment is to be completed individually. Working in pairs/groups is not permitted. Learning goals To become comfortable using Qt Creator to edit, build, run, and debug simple C++ programs. To practice writing C++ functions that manipulate numbers and strings. To learn basic use of the SimpleTest framework for unit tests and time trials. Assignment parts This assignment consists of two parts. Click on the links below for the full instructions. Perfect Numbers is a warmup exercise involving number theory, algorithms, and optimization. It gives you a guided transition into C++ and the testing and debugging tools we use. You can start on this task right away - and we recommend doing so! Completing the warmup in the first few days reserves the better part of the week for the bigger second part. Soundex Search is a complete program that demonstrates a nifty algorithm for matching and grouping names based on their pronunciation. This program uses C++ strings, console I/O, and the Vector class. There is a substantial chunk of code for you to write, so get an early start to give yourself sufficient time to work through issues and reach out for help if you hit any snags. Getting started Starter project The starter project is provided as a zip archive. Download the zip, extract the files, and move the project folder to your CS106B folder. Open the .pro file in Qt Creator to get started. Resources The CS106B guide to SimpleTest on testing your code using the SimpleTest framework. A guide to C++ strings written by our awesome colleague Keith Schwarz. This Python to C++ transition guide points out syntactical and functional differences between the two languages. Thank you to section leaders Jillian Tang and Ethan Chi for this wonderful resource. Resolving Common Build/Run Errors, compiled by section leader Jillian Tang. The CS106B Style Guide explains the rubric and standards we use when evaluating the style of your code. Getting Help Keep an eye on the Ed forum for an announcement of the Assignment 1 YEAH (YEAH = Your Early Assignment Help) group session where our veteran section leaders will answer your questions and share pro tips. We know it can be daunting to sit down and break the barrier of starting on a substantial programming assignment - come to YEAH for advice and confidence to get you on your way! We also here to help if you get run into issues along the way! The Ed forum is open 24/7 for general discussion about the assignment, lecture topics, the C++ language, using Qt, and more. Always start by searching first to see if your question has already been asked and answered before making a new post. To troubleshoot a problem with your specific code, your best bet is to bring it to the LaIR helper hours or office hours. Submit Before you call it done, run through our submit checklist to be sure all your ts are crossed and is are dotted. Then upload your completed files to Paperless for grading. Please submit only the files you edited; for this assignment, these files will be: perfect.cpp soundex.cpp short_answer.txt You don't need to submit any of the other files in the project folder. Submit to Paperless That's it; you're done! Congratulations on finishing your first CS106B assignment!
https://cs106b.stanford.edu/assignments/2-adt/easter_egg/
Here is a hidden file on the course website, buried deep among the many other pages containing important course information. For your entertainment, it also contains an easter egg, which can only be found by using the "Search" feature in the top left corner of the website... Your quote for today: Have a GREAT day! Presenting... Bad Trombone Guy Your browser does not support the audio element. Latest release from indie band College Avenue Lockdown (mixed by sons Rein & Kalev, husband Matt on trombone, Rein on drum kit, vocals by Julie) A classic XKCD comic that we can all relate to:
https://cs106b.stanford.edu/assignments/2-adt/
Due Monday, January 29 at 11:59 PM Submit to Paperless. Deadline is 11:59 PM. The late day policy gives you the ability to self-grant an extension (as long as you have not used all your late days); we trust you will make reasonable and sparing use of this power. Be sure to reserve late days for emergencies. Reminder: You have a limited pool of late days. You have a total of 4 late days to use throughout the quarter, but you cannot use more than 2 late days per assignment. Late days are expended in 24-hour blocks. See the Assignments page for more details. The recent lectures have introduced you to some of the classic Abstract Data Types (ADTs), and now it's time to put that knowledge to use. In this assignment, you will write code that leverages those ADTs to implement some nifty algorithms. The tasks may sound a little daunting at first, but given the powerful tools in your arsenal, each requires a very manageable amount of code. Let's hear it for abstraction! This assignment is to be completed individually. Working in pairs/groups is not permitted. Learning goals To more fully experience the joy of using pre-written classes. Most of the heavy-lifting is handled by the collection ADTs. To stress the notion of abstraction as a mechanism for managing data and providing functionality without revealing the representational details. To learn how to model and solve problems using classic data structures such as vectors, grids, stacks, queues, sets, and maps. Assignment parts This assignment consists of a short warmup exercise using the debugger. two coding tasks that use of variety of ADTs, and short ethical reflection on efficiency. Warmup Practice with testing and debugging on different abstract data types. Do the warmup first! Maze A Grid of walls and corridors is used to represent a maze, and the Vector, Stack, Queue, and Set ADTs are used in a clever algorithm to find a solution path that escapes the maze. Search Engine A Map is used to associate words with a Set of documents containing that word. Using the map, you can find matching entries that contain terms from simple or compound queries, and construct a mini search engine. Beyond Algorithmic Analysis In this section, you will consider some of the human and societal impacts of designing and optimizing efficient software systems. The two coding tasks are roughly comparable to each other in size and scope, so pace yourself to complete each in about three days. Note: The code you will write for Assignment 2 is considerably more complex than Assignment 1, so be sure to start without delay! Getting started Starter project The starter project is provided as a zip archive. Download the zip, extract the files, and move the project folder to your CS106B folder. Open the .pro file in Qt Creator to get started. Resources The CS106B Guide to Testing The CS106B Style Guide Resolving Common Build/Run Errors, compiled by section leader Jillian Tang. Stanford library documentation for Vector, Grid, Stack, Map, Set Getting Help Keep an eye on Ed for an announcement of the YEAH (YEAH = Your Early Assignment Help) group session where our veteran section leaders will answer your questions and share pro tips. We know it can be daunting to sit down and break the barrier of starting on a substantial programming assignment - come to YEAH for advice and confidence to get you on your way! The Ed forum is open 24/7 for questions about the assignment, lecture topics, the C++ language, using Qt, and more. Please first search Ed to see if your question has already been asked and answered before making a new post. To troubleshoot a problem with your specific code, your best bet is to bring it to the LaIR helper hours or office hours. Submit Before you call it done, run through our submit checklist to be sure all your ts are crossed and is dotted. Then upload your completed files to Paperless for grading. Please submit only the files you edited; for this assignment, these files will be: maze.cpp search.cpp short_answer.txt You don't need to submit any of the other files in the project folder. Submit to Paperless Note: On Paperless, all due dates and submission times are expressed in Pacific time.
https://cs106b.stanford.edu/assignments/0-namehash/
Due Friday, January 12 at 11:59 PM For this assignment, you are to install Qt Creator and then work through compiling, running, and debugging a sample program. This confirms you and your computer are ready for the awesome adventures to come this quarter! Step 1) Install Qt Creator Install the Qt Creator development tools by following the step-by-step instructions in our Qt Installation Guide. Note that some of the recommended settings (like "save all files before build") are very important, so make sure to apply these settings after you've successfully installed Qt creator. If you run into a snag when installing Qt, we're here to help. The section leaders will hold a special help session for Qt installation 5 - 7 PM Thursday, January 11 in Durand 353. Bring your computer and we can diagnose the issue and resolve to get you on your way. You can also post install questions on the Ed forum. Step 2) Download starter project For each assignment, we create a starter project and post it as a ZIP archive. Here is the archive for this assignment: Starter project Download the archive and extract all. Move the starter project folder into your CS106B folder. The starter project contains two files: NameHash.pro (Qt project file) and NameHash.cpp (C++ source file). Open the .pro project file in Qt Creator. The first time you open a new project, Qt Creator will ask you to configure it; select the default kit (Qt 6.x) from your Qt install. Step 3) Hash your name In the Qt Creator window, click the green triangle in the lower-left to build and run the program. When the program runs, the console window appears and will prompt you to enter your preferred first and last names. The program then computes a hash code from your name. The hash code is like a "fingerprint", unique to your name and unlikely to match anyone else's. Write down the hash code for your name; you'll be asked for it when you submit. While you are here, skim the code for a preview of C++ syntax and control flow. Don't worry if you don't fully understand the math behind the algorithm just yet, consider it a teaser for ideas we will explore together later in the quarter. Step 4) Practice with debugger Knowing your debugger is a key component in your programming tool belt. Our colleague Keith Schwarz wrote a wonderful tutorial to introduce students to the Qt debugger. The tutorial guides you through using the debugger to inspect the NameHash program. Open the debugger tutorial and follow along step-by-step. Along the way there is a point where the tutorial asks you to remember a special value that you see in the debugger. Write down this special value; you'll be asked for it when you submit. Step 5) Read course policies (Syllabus, Honor Code) Please read the pages on the course website that detail our policies for the syllabus and Honor Code. We want to ensure that you know what to expect from us and what we will expect from you. If you have any questions or concerns about the course policies, make a post on Ed or via private email to clarify or resolve issues before choosing to enroll. Step 6) Submit Once you've finished everything, fill out this form while logged into your Stanford Google account: Submit Google form: https://forms.gle/wJZtYQSXPvWh64bv5 Enter the numbers from Steps 3 and 4, confirm that you understand the course policies, and submit the form. Congrats and welcome to CS106B!
https://cs106b.stanford.edu/lectures/01-welcome/
Lecture quiz on Canvas Lecture video on Canvas Lecture Video Contents 1. Preliminary Note (Welcome, and Don't Panic!) 2. Annotated Syllabus Prezi 3. Task List 4. Supplementary Productivity Tip: Browser Shortcuts 5. Hello, world! 6. What's next? Preliminary Note (Welcome, and Don't Panic!) Thanks for being so warm and receptive on Day #1 today, everyone. I know you have a LOT of information coming at you already in this class. CS106B can feel like a beast of a machine sometimes. If you ever feel lost, overwhelmed, or have questions about where to find things, please don't hestitate to ask! Probably the best avenue for that is on the Ed forum. There are already some great questions there. Remember: This class can get intense, but you have a very active, caring, dedicated course staff here to support you every step of the way. Annotated Syllabus Prezi We started with an annotated overview of the syllabus today, Prezi style: CS106B - Winter '24 Annotated Syllabus Task List You already have a number of tasks to work through and a few upcoming deadlines. Here's a quick summary: Syllabus Quiz. The Syllabus Quiz (Quiz #0) is now available on Canvas, is this Friday at 11:59 and is 2% of your final course Install Qt. Work through the Qt Creator Installation Guide to get the Qt Creator installed. This is the official IDE of CS106B, and you will need it this quarter in order to complete your assignments and capitalize on the all the awesome Stanford C++ Library goodies we'll be using. Getting this set up is also part of A0. (See below.) Start A0. Assignment 0 is posted and is Friday at 11:59 (Pacific time). See the Assignments page. Let us help you! If you hit a snag and need help installing the Qt Creator, visit office hours this week or attend the Qt Creator intall help session this Thursday. Details for the Qt Creator session will be announced in class and posted on Ed. Check your units. If you are an undergraduate, must take this course for 5 If you registered for 3 or 4 units and are not a graduate student, please rectify this issue in Axess. Sign up for section. Section sign-up will be available this Thursday through Sunday through Paperless. Supplementary Productivity Tip: Browser Shortcuts You can enhance your productivity by setting keyword shortcuts in your web browser that take you directly to various pages you visit frequently - such as the homepage for this course (possibly a direct link to the Lectures page), the Ed forum, or the Living Omni-Grid. This is useful for minimizing clicks and keystrokes and saving yourself the time and cognitive effort it takes to parse through different page suggestions that pop up in your web browser's navigation bar as you're typing. For Google Chrome users, see the following page for help getting that set up: https://lifehacker.com/how-to-set-keyword-bookmarks-in-google-chrome-5476033 This is especially helpful if, say, you were in another class that used an Ed forum, and so typing "ed" in your web browser's location bar always suggests last quarter's forum link. Some shortcuts I use, personally, include: keyword link b CS106B homepage: https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1244/ ed Ed forum: https://edstem.org/us/courses/51213/ og Living Omni-Grid: https://docs.google.com/spreadsheets/d/1klB-kNo6D-5i3l1joROtTqiPoGB8YorA sm Stanford Mail: (direct link to my university inbox) Hello, world! At the very end of class, I loaded up the Qt Creator and threw down the code for a simple "Hello, world!" program that uses the Stanford C++ Library's console for displaying its output. Here's the code: #include <iostream>#include "console.h"using namespace std;int main(){ cout << "Hello, world!" << endl; return 0;} The output was, of course: Hello, world! What's next? On Wednesday, we'll delve into some basics of C++ and see an intense amount of code. You will want to come prepared to take lots of notes. Our next quiz will unlock on Wednesday, as well. Keep in mind that you can always check out the Living Omni-Grid or the Lectures page to see what's coming up next, as well.
https://cs106b.stanford.edu/lectures/05-stack-queue/
Today we will discuss use of Stack and Queue. These containers store data in an ordered format and are used to solve many problems. Readings: Text 5.1 - 5.3, Class documentation for Stack and Queue Lecture quiz on Canvas Lecture video on Canvas Lecture Video Contents 1. Announcements 2. Attachments 3. Preliminaries: Client-Side Approach to ADTs 4. Stack Overview 5. Stack Examples in Code 6. Stack Applications 7. Vectors as Stacks (and a Note About the Power of Abstraction!) 8. Queue Overview 9. Queue Examples in Code 10. Mod Operator (%) 11. Queue Applications 12. Grid Redux 13. Supplementary Stack Application: Postfix Notation 14. What's next? 15. Exam Prep Announcements Assignment 1 is due Monday at 11:59 PM. Please be sure to head to LaIR early for help with these assignments (and to ensure that you don't get stuck in a really long queue). We appreciate your patience in LaIR. Please keep in mind we're doing our best to help a large number of students. Solutions to each week's section problems will be posted to the course website on Friday afternoons. Be sure to work through any problems you found tricky or that your SL didn't have time to cover this week. Your next batch of quizzes will be due Wednesday at 11 AM. Attachments For ease of access, here are the stack and queue vizualization programs I used in lecture today: StackViz.zip QueueViz.zip Preliminaries: Client-Side Approach to ADTs I mentioned at the top of class today that we're currently taking a client-side approach to the ADTs we're exploring. That means we're exploring how to use them, but not their nitty-gritty, behind-the-scenes implementation details. However, we will discuss those implementation details later this quarter, after we've built up some additional requisite knowledge for doing so. In the meantime, exploring ADTs from the client side empowers us to solve all kinds of interesting problems. Stack Overview Attachment: StackViz.zip The first ADT we saw today was the stack. A stack is a LIFO (last-in, first-out) data structure. It generally supports a limited set of operations: Member Function Description clear() removes all elements from the stack equals(stack) returns true if the two stacks contain the same elements in the same order, false otherwise isEmpty() returns true if the stack contains no elements, false otherwise peek() returns the element on the top of the stack without removing it pop() removes the element from the top of the stack and returns it push(value) pushes value onto the stack size() returns the number of values in the stack . . . For an exhaustive list, see: Stanford Stack class Notably, a stack does not support a search operation or an operation to find and remove an element with a specific value. Before delving into actual code, we explored the behaviors of stacks through the StackViz program attached above. Stack Examples in Code To create a stack using the Stanford C++ Libraries, we must include the following: #include "stack.h" The syntax for creating a stack is as follows: Stack< DATA_TYPE > VARIABLE_NAME ; (Important note!) We must capitalize the 'S' in "Stack" when declaring one in code. As with the other ADTs we have seen this quarter, C++ has its own built-in version of a stack that uses a lowercase 's'. Here's the first example we saw of an actual stack in class today: #include <iostream>#include "console.h"#include "stack.h"using namespace std;int main(){ Stack<int> s; s.push(10); s.push(20); s.push(15); s.push(12); while (!s.isEmpty()) { cout << s.pop() << endl; } return 0;} output: 12152010 We also saw the following, which uses a stack to print the characters of a string in reverse order: #include <iostream>#include "console.h"#include "stack.h"using namespace std;int main(){ string str = "muffins"; Stack<char> myStack; for (char ch : str) { myStack.push(ch); } while (!myStack.isEmpty()) { cout << myStack.pop(); } cout << endl; return 0;} output: sniffum We also saw that we can print a stack using the << operator. This is super helpful for debugging, and we saw that C++'s built-in stack does not support that behavior: #include <iostream>#include "console.h"#include "stack.h"using namespace std;int main(){ Stack<int> s; s.push(10); s.push(20); s.push(15); s.push(12); cout << "Stack contents: " << s << endl; return 0;} output: Stack contents: {10, 20, 15, 12} (Not mentioned in class.) We can also use the == and != operators to check whether two stacks are the same (i.e., they contain the same elements in the same order). For example: #include <iostream>#include "console.h"#include "stack.h"using namespace std;int main(){ Stack<int> s1; Stack<int> s2; Stack<int> s3; s1.push(12); s1.push(10); s2.push(12); s2.push(10); s3.push(12); s3.push(10); s3.push(10); if (s1 == s2) { cout << "s1 == s2" << endl; } else { cout << "s1 != s2" << endl; } if (s1 == s3) { cout << "s1 == s3" << endl; } else { cout << "s1 != s3" << endl; } return 0;} output: s1 == s2s1 != s3 Stack Applications Stacks come up all over the place in computer science. Here are a few of the applications we discussed today: Stacks are useful for reversing things! See the example above in which we print the characters of a string in reverse order. We talked about the call stack, which your programs use to keep track of which functions have been called in which order and where we need to return to when we hit the end of some function's execution. Toward the end of today's notes, there is a supplementary section that talks about how stacks can be used to process arithmetic postfix expressions. Vectors as Stacks (and a Note About the Power of Abstraction!) We saw that we could actually implement a stack using a vector. The following two programs effectively have the same functionality: Stack approach: #include <iostream>#include "console.h"#include "stack.h"using namespace std;int main(){ Stack<int> s; s.push(10); s.push(20); s.push(15); cout << s.pop() << endl; cout << "Stack contents: " << s << endl; return 0;} output: 15Stack contents: {10, 20} Vector approach: #include <iostream>#include "console.h"#include "vector.h"using namespace std;int main(){ Vector<int> v; v.add(10); v.add(20); v.add(15); cout << v.remove(v.size() - 1) << endl; cout << "Vector contents: " << v << endl; return 0;} output: 15Vector contents: {10, 20} Notice, however, that the stack version is not only easier to read, but also less error prone. There is less code to parse (we can infer its semantics with a quick glance at the operations being performed), and we don't have to stop to consider whether we're pushing and popping at the correct index. With the vector approach, we might have to stop to consider the relationship between v.add() and v.remove(v.size() - 1) to ensure we understand what the code is doing. Someone coding this up with vectors could also easily remove elements from the wrong end of the vector or have an off-by-one error that causes us to go out of bounds. Those problems simply don't exist with the stack approach, where the details of the s.push() and s.pop() operations are abstracted away from us and we can assume they work as intended. Queue Overview Attachment: QueueViz.zip We then discussed the queue ADT. A queue is a FIFO (first-in, first-out) data structure. Like the stack, it generally supports a limited set of operations: Member Function Description clear() removes all elements from the queue dequeue() removes and returns the frontmost element in the queue enqueue(value) adds value to the back of the queue equals() returns true if the two queues contain the same elements in the same order, false otherwise isEmpty() returns true if the queue contains no elements, false otherwise peek() returns the frontmost element in the queue without removing it size() returns the number of values in the queue . . . For an exhaustive list, see: Stanford Queue class Before delving into actual code, we explored the behaviors of queues through the QueueViz program attached above. Queue Examples in Code To create a queue using the Stanford C++ Libraries, we must include the following: #include "queue.h" The syntax for creating a queue is as follows: Queue< DATA_TYPE > VARIABLE_NAME ; (Important note!) We must capitalize the 'Q' in "Queue" when declaring one in code. This distinguishes it from C++'s built-in queue, which has a lowercase 'q'. (You're seeing the trend here, yes?) Here are the first examples we saw of actual queue code in class today: Warning! This doesn't work as intended! #include <iostream>#include "console.h"#include "queue.h"using namespace std;int main(){ Queue<int> q; for (int i = 1; i <= 6; i++) { q.enqueue(i); } // This does not actually remove and print all elements from the queue! for (int i = 0; i < q.size(); i++) { cout << q.dequeue() << endl; } return 0;} output: 123 The following is a more conventional way to loop through a queue while emptying it out. Recall that a coding idiom is a good, solid, widely-used approach to accomplishing a particular task. Idiom #1 #include <iostream>#include "console.h"#include "queue.h"using namespace std;int main(){ Queue<int> q; for (int i = 1; i <= 6; i++) { q.enqueue(i); } // Much better. :) while (!q.isEmpty()) { cout << q.dequeue() << endl; } return 0;} output: 123456 The following idiom can be used to loop through a queue while emptying it out (as we did above), but it can also be used to process all the original elements of a queue while adding others to the back: Idiom #2 #include <iostream>#include "console.h"#include "queue.h"using namespace std;int main(){ Queue<int> q; for (int i = 1; i <= 6; i++) { q.enqueue(i); } // Keep track of original queue size. This loop will only do 6 iterations now, // even though we're adding some elements back into the queue as we go. int ogSize = q.size(); for (int i = 0; i < ogSize; i++) { int val = q.dequeue(); cout << val << endl; // Even values get added back to the queue. if (val % 2 == 0) { q.enqueue(val); } } cout << "Final queue contents: " << q << endl; return 0;} output: 123456Final queue contents: {2, 4, 6} Mod Operator (%) We briefly saw the mod operator (%) in the above example. Recall that the mod operator returns the remainder after division. So, 5 % 2 = 1, since 5 / 2 = 2 R 1. Similarly, 17 % 3 = 2 since 17 / 3 = 5 R 2. Queue Applications Queues come up all over the place in real-world applications. A few examples from today: Purchase queues for online ticket sales. Login queues for online games. Printer queues for processing multiple print jobs. We will see additional applications of queues later this quarter. There's at least one very common application of queues that we'll see when we get to our section on graph theory; they can be used to implement an algorithm called breadth-first search. A related algorithm, called depth-first search, can actually be implemented with a stack. Grid Redux Finally, at the end of class, I rounded back to grids to show the following: We can use a for-each loop to loop through and display the contents of a grid. These are processed in a row-major fashion. We can use nested for loops to display the contents of a grid in the same order as above. We can loop through all the valid coordinates in a grid as GridLocation objects, and those can be used to access specific grid elements. (Not mentioned in class.) We can also send a grid directly to cout and get a nicely formatted string that conveys the grid contents. #include <iostream>#include "console.h"#include "grid.h"using namespace std;int main(){ Grid<int> g(2, 3); // Just random values. :) g[0][0] = 41; g[0][1] = 53; g[0][2] = 98; g[1][0] = 18; g[1][1] = 21; g[1][2] = 16; // Option #1: For-Each Loop cout << "Grid for-each loop:" << endl; for (int i : g) { cout << i << endl; } cout << endl; // Option #2: Nested for loops. cout << "Grid nested loops:" << endl; for (int row = 0; row < g.numRows(); row++) { for (int col = 0; col < g.numCols(); col++) { cout << g[row][col] << endl; } } cout << endl; // Option #3: Iterate over grid locations. cout << "Grid locations:" << endl; for (GridLocation loc : g.locations()) { cout << loc << " -> " << g[loc] << endl; } cout << endl; // Option #4: Just dump directly to cout. cout << "Grid contents:" << endl; cout << g << endl << endl; // Example of manual specification of GridLocation. GridLocation myLoc(0, 1); cout << g[myLoc] << endl; return 0;} output: Grid for-each loop:415398182116Grid nested loops:415398182116Grid locations:r0c0 -> 41r0c1 -> 53r0c2 -> 98r1c0 -> 18r1c1 -> 21r1c2 -> 16Grid contents:&#123;&#123;41, 53, 98}, {18, 21, 16}}53 Supplementary Stack Application: Postfix Notation Here's an additional stack application for your consideration: When we (as humans) process an arithmetic expression such as "3 + 5 * 2 - 12 / (2 * 3)," we have to respect order of operations, which means that we bounce around to different parts of the expression and potentially make multiple passes through the whole expression as we work to resolve its value. The arithmetic expression above is presented in what we call "infix notation." The arithmetic operators (+, -, *, /) come in between their operands (the numbers upon which they're operating). An alternative form of that expression using "postfix notation" (also sometimes called Reverse Polish Notation), is as follows: Original expression (using infix notation): 3 + 5 * 2 - 12 / (2 * 3) Equivalent expression (using postfix notation): 3 5 2 * + 12 2 3 * / - With postfix expressions, the given operator comes after the operands to which it applies. We can actually process a postfix expression quite easily from left to right, token-by-token, using a stack -- without having to make multiple passes through the expression! The ease of left-to-right processing makes postfix a great representational choice for expressions that are being parsed by a program (like a calculator application). The stack-based algorithm for processing them is as follows: Warning! The following algorithm assumes a valid, well-formed postfix expression as its input. There are some gotchas to consider if the postfix expression is not well-formed. (See Exercise #4 in today's exam prep section.) Let s be an initially empty stack. For each token (tok) in your postfix expression: If tok is a numeric value: Push tok onto s. If tok is an operator (+, -, *, /): Let rightHandOperand = s.pop(). Let leftHandOperand = s.pop(). Apply the given operator (tok) to the leftHandOperand and rightHandOperand and push the resulting value onto s. Note that the first value we pop above must be the right-hand operand, and the second must be the left-hand operand. This makes no difference with addition and multiplication, but it matters when performing subtraction and division. Return s.pop(). For example, here's how the algorithm resolves the infix expression above (3 5 2 * + 12 2 3 * / -). Note that we process the tokens in that expression one-by-one, from left to right: 3 is numeric. Push onto stack. Current stack contents (from bottom to top): {3} 5 is numeric. Push onto stack. Current stack contents (from bottom to top): {3, 5} 2 is numeric. Push onto stack. Current stack contents (from bottom to top): {3, 5, 2} * is operator: Pop stack for right-hand operand: 2 Pop stack for left-hand operand: 5 Perform operation: 5 * 2 = 10 Push result (10) onto stack. Current stack contents (from bottom to top): {3, 10} + is operator: Pop stack for right-hand operand: 10 Pop stack for left-hand operand: 3 Perform operation: 3 + 10 = 13 Push result (13) onto stack. Current stack contents (from bottom to top): {13} 12 is numeric. Push onto stack. Current stack contents (from bottom to top): {13, 12} 2 is numeric. Push onto stack. Current stack contents (from bottom to top): {13, 12, 2} 3 is numeric. Push onto stack. Current stack contents (from bottom to top): {13, 12, 2, 3} * is operator: Pop stack for right-hand operand: 3 Pop stack for left-hand operand: 2 Perform operation: 2 * 3 = 6 Push result (6) onto stack. Current stack contents (from bottom to top): {13, 12, 6} / is operator: Pop stack for right-hand operand: 6 Pop stack for left-hand operand: 12 Perform operation: 12 / 6 = 2 Push result (2) onto stack. Current stack contents (from bottom to top): {13, 2} - is operator: Pop stack for right-hand operand: 2 Pop stack for left-hand operand: 13 Perform operation: 13 - 2 = 11 Push result (11) onto stack. Current stack contents (from bottom to top): {11} End of expression. Return sole element on stack as final result: 11 Indeed, the original infix expression that correponds to this postfix expression, 3 + 5 * 2 - 12 / (2 * 3), is equal to 11. You might be wondering where I got the postfix version of that original infix expression. It turns out there's an algorithm for converting infix expressions to postfix expressions that also uses a stack! If you're interested, you can read more about that on GeeksforGeeks: https://www.geeksforgeeks.org/convert-infix-expression-to-postfix-expression/ What's next? On Monday, we'll examine two more ADTs: sets and maps. Following that, we'll delve into two major topics that will stick with us for the rest of the quarter: recursion and big-oh runtime analysis. Exam Prep 1. As always, be sure to trace through all the code presented in class today to ensure that you understand how it works. Ideally, you should take a break after reviewing today's notes and then try to replicate many of those examples from scratch. 2. Be sure to review the section in today's notes labeled "(Not mentioned in class.)" 3. Read through the supplementary section of notes above, titled "Stack Application: Postfix Notation." Then write a function that can process postfix expressions using the stack-based algorithm presented in that section. The function should take two parameters: a string representing the postfix expression to be processed, and a reference to an integer where the final result should be stored. The function should return true if it successfully processes the given expression, false otherwise. If the function returns false, the reference parameter should remain unchanged. The function signature is as follows: bool processPostfix(string expr, int& result); For example function calls, see the test cases provided below. For this problem, you may make the following assumptions: If our postfix string is valid, all tokens will be separated with a single space. For example: "25 12 * 3 + 84 -" If our postfix string is valid, all values will be integers, and the only operators will be +, -, *, and / In completing this exercise, you might find the following functions from strlib.h useful: stringSplit() stringIsInteger() stringToInteger() Here are some test cases to get you started: Spoiler Alert! These test cases for invalid postfix expressions contain spoilers for Exercise #4. #include <iostream>#include "console.h"#include "SimpleTest.h"#include "stack.h"#include "strlib.h"using namespace std;PROVIDED_TEST("valid postfix expressions"){ int result = 0; EXPECT_EQUAL(processPostfix("5 10 +", result), true); EXPECT_EQUAL(result, 15); EXPECT_EQUAL(processPostfix("3 8 *", result), true); EXPECT_EQUAL(result, 24); EXPECT_EQUAL(processPostfix("5 10 12 + -", result), true); EXPECT_EQUAL(result, -17); EXPECT_EQUAL(processPostfix("10 12 + 5 -", result), true); EXPECT_EQUAL(result, 17); EXPECT_EQUAL(processPostfix("5 2 * 3 + 4 -", result), true); EXPECT_EQUAL(result, 9); EXPECT_EQUAL(processPostfix("2 3 + 4 5 + *", result), true); EXPECT_EQUAL(result, 45); EXPECT_EQUAL(processPostfix("2 3 4 * + 5 +", result), true); EXPECT_EQUAL(result, 19); EXPECT_EQUAL(processPostfix("2 3 + 4 +", result), true); EXPECT_EQUAL(result, 9); EXPECT_EQUAL(processPostfix("2 3 4 + +", result), true); EXPECT_EQUAL(result, 9); EXPECT_EQUAL(processPostfix("2 3 1 * + 9 -", result), true); EXPECT_EQUAL(result, -4); EXPECT_EQUAL(processPostfix("10", result), true); EXPECT_EQUAL(result, 10);}PROVIDED_TEST("invalid postfix expressions"){ int result = 0; EXPECT_EQUAL(processPostfix("5 10 + +", --result), false); EXPECT_EQUAL(result, -1); EXPECT_EQUAL(processPostfix("3 8 * 0 / 5 +", --result), false); EXPECT_EQUAL(result, -2); EXPECT_EQUAL(processPostfix("", --result), false); EXPECT_EQUAL(result, -3); EXPECT_EQUAL(processPostfix("10 12 + 13", --result), false); EXPECT_EQUAL(result, -4); EXPECT_EQUAL(processPostfix("10 12 13 +", --result), false); EXPECT_EQUAL(result, -5); EXPECT_EQUAL(processPostfix("10 + 20", --result), false); EXPECT_EQUAL(result, -6); EXPECT_EQUAL(processPostfix("- 10 8", --result), false); EXPECT_EQUAL(result, -7); EXPECT_EQUAL(processPostfix("- 10", --result), false); EXPECT_EQUAL(result, -8); EXPECT_EQUAL(processPostfix("-", --result), false); EXPECT_EQUAL(result, -9); EXPECT_EQUAL(processPostfix("10 15 + sandwhich", --result), false); EXPECT_EQUAL(result, -10);}int main(){ runSimpleTests(ALL_TESTS); return 0;} 4. What errors might we encounter while processing a postfix expression that would indicate that the expression was invalid or malformed? Modify your solution to the previous problem to account for each of these scenarios. Highlight for solutions: Encountering a token in our input string that is neither an integer nor a valid operator. Encountering an operator in our expression when stack.size() < 2. In this case, we don't have enough operands to perform the desired operation. Encountering division by zero. Encountering a final stack with stack.size() != 1. If there is nothing in the stack when we finish processing our expression, or if the final stack contains multiple values, the original expression must have been malformed. 5. In the test cases for invalid postfix expressions given above (in Exercise #3), result is being decremented with each new test case. What benefit does this have compared to simply setting result = -1 and always checking that result is still -1 when returning from each of those individual test cases? Highlight for solution: If we always check that result is -1 in those test cases, someone might think the goal of processPostfix() is to set result equal to -1 in the event that a postfix expression is malformed, and if they did so, they would get a false sense of security from passing all those test cases. In actuality, the function is supposed to leave that parameter completely unchanged when it encounters a malformed postfix expression. Changing result before we make a new call to processPostfix() with a malformed expression -- and checking that its value is unchanged when we return from that function -- more clearly conveys (and tests!) that desired behavior.
https://cs106b.stanford.edu/lectures/04-vector-grid/
In this lecture, we will introduce use of Vector and Grid and talk about what testing fundamentals look like in CS106B. Readings: Text 2.5-2.9, 5.1 and class documentation for Vector and Grid Lecture quiz on Canvas Lecture video on Canvas Lecture Video Contents 1. Preliminaries 2. Announcements 3. Warmup and Reinforcement 4. Design Principles: Functional Decomposition and More 5. Testing with SimpleTest.h 6. Abstract Data Types (ADTs): Introduction and Overview 7. Vector Overview 8. Vector Functions and Sample Code 9. Runtime Comparison: add(value) vs. insert(0, value) 10. Grid Overview 11. Grid Functions and Sample Code 12. Passing Containers by Reference 13. Common Pitfalls 14. What's next? 15. Exam Prep Preliminaries If the following text does not appear on a pinkish-purple background, please hit CTRL+SHIFT+R (CMD+SHIFT+R on Mac) (not just CTRL+R or CMD+R) to ensure the style sheet for this site is reloaded and applied to this page: tada! Announcements Please be sure to glance through the following documents sometime this week: Recommended Settings for Qt Creator &larr; Lots of quality-of-life improvements! Assignment Submission Checklist Style Guide If you missed section sign-up or want to swap swap sections, that's still possible in Paperless! Section starts this week, and section attendance counts for 5% of your grade. Be sure you're reading Clinton's weekly post on Ed. Your next quiz series starts rolling out today and will be due next Wednesday at 11 AM. Have a burning question during lecture? Clinton is creating a megathread at the start of each lecture where you can get responses from him in real time. This is great for questions that might not be relevant to the whole class or questions that we just don't have time to get to because of the pace at which we're covering material. Please head to LaIR for assignment help early. LaIR gets packed the day of and before each assignment deadline. Avoid frustration and long wait times by starting early and getting help early. Warmup and Reinforcement We started with a program designed to determine whether a given username appears in a given password string -- and to print an alert if so: Warning: This code suffers from several major design issues. See the following section of notes ("Design Principles") for more. #include <iostream>#include "console.h"using namespace std;int main(){ string s = "Sean"; string p = "sean'spassword"; // How can we determine whether the given username (s) appears in the password (p)? if ( ??? ) { cout << "Uh oh! Bad password." << endl; } else { cout << "Hooray!" << endl; } return 0;} The solution, which we found by glancing through the functions listed in the strlib.h docs, is: Warning: This code suffers from several major design issues. See the following section of notes ("Design Principles") for more. #include <iostream>#include "console.h"#include "strlib.h"using namespace std;int main(){ string s = "Sean"; string p = "sean'spassword"; // How can we determine whether the given username (s) appears in the password (p)? if (stringContains(toLowerCase(p), toLowerCase(s))) { cout << "Uh oh! Bad password." << endl; } else { cout << "Hooray!" << endl; } return 0;} We then augmented this to check whether the username appears in the password string if we extract just the alphabetic portion: Warning: This code suffers from several major design issues. See the following section of notes ("Design Principles") for more. #include <iostream>#include "console.h"#include "strlib.h"using namespace std;int main(){ string s = "Sean"; string p = "s1e1a1n1'1s1p1a1s1s1w1o1r1d"; string p0; for (int i = 0; i < p.length(); i++) { if (isalpha(p[i])) { p0 += p[i]; } } if (stringContains(toLowerCase(p0), toLowerCase(s))) { cout << "Uh oh! Bad password." << endl; } else { cout << "Hooray!" << endl; } return 0;} Design Principles: Functional Decomposition and More The code above suffers from several flaws that make it difficult to read and, therefore, difficult to debug, augment, and maintain. Issues include: We are not using meaningful variable names. Everything is dumped into main(), leading to code that is difficult for someone who's not familiar with the code to parse through and debug. As written, if our program isn't working correctly, it can be hard to determine where things are going wrong, because there's so much happening all in one place. It's also hard to subject individual components of the code to robust testing when they're all slopped into main() like this. There are no comments to assist the reader in figuring out what's going on. However, the ideal scenario would be to rewrite the code in a way that makes comments somewhat unnecessary. We solved the broader structural issues by moving chunks of code into functions that serve a single purpose and naming those functions with verb phrases that conveyed what they do. (Key Concept!) Breaking up a task into constituent functions that each fulfill a single purpose is called functional decomposition and improves the readability and maintainability of our code. #include <iostream>#include "console.h"#include "strlib.h"using namespace std;string extractAlpha(string s){ string result; for (int i = 0; i < s.length(); i++) { if (isalpha(s[i])) { result += s[i]; } } return result;}bool passwordChecksOut(string username, string password){ string alphaPortion = extractAlpha(password); return !stringContains(toLowerCase(alphaPortion), toLowerCase(username));}int main(){ string username = "Sean"; string password = "s1e1a1n1'1s1p1a1s1s1w1o1r1d"; if (passwordChecksOut(username, password)) { cout << "Hooray!" << endl; } else { cout << "Oh no! Bad password." << endl; } return 0;} This code is now much more readable, and we have a few units that can be independently and rigorously tested: the extractAlpha() and passwordChecksOut() functions. The introduction of meaningful variable names and function names also means that we needn't bog down our code with comments explaining what's going on. A nice side effect of this approach is that we now have one place where all the password-checking logic is neatly bundled together and isolated from the rest of the code. If we want to add new restrictions (such as requiring the password be at least 8 characters long), there is a very clear place to add the code for that: the passwordChecksOut() function. Testing At this point, we turned our attention to testing. The Stanford C++ Library has a powerful testing framework that you can use with just a few simple steps: #include "SimpleTest.h" in your code Write your own tests using STUDENT_TEST("description of test") { ... } Populate each SIMPLE_TEST with EXPECT_EQUAL( ... ) statements that verify the results of various operations. Call runSimpleTests(ALL_TESTS) to cause the tests to be run. Further information about all these steps -- as well as information about other testing functionality that is available to you -- can be found in the SimpleTest Guide. Note that in programming assignments, you can (and should!) make use of STUDENT_TEST to add your own test cases, but you should be careful not to modify any test we have provided for you. Those are created using PROVIDED_TEST instead of STUDENT_TEST. (Key take-away!) In discussing things to test for in extractAlpha(), we came up with all kinds of scenarios: What if all the characters are alphabetic? What if there are non-alpha characters are at the end of the string? What if there are non-alpha characters are at the beginning of the string? What if there are non-alphabetic characters in the middle of the string? What if there are alternating alphabetic and non-alphabetic characters? What if we have only non-alphabetic characters, and no alphabetic ones? What if our non-alphabetic characters are not digits, but other symbols ('$', '*', etc.)? What if we have an empty string (a string with zero characters)? What if we have a string with exactly 1, 2, or 3 characters? What if we have a very long string? What if our string is even in length? What if the length is odd? These are the sorts of things we hope you will be thinking about as you develop test cases for your own programs this quarter. Here is the resulting code with test cases for the extractAlpha() function. #include <iostream>#include "console.h"#include "SimpleTest.h"#include "strlib.h"using namespace std;string extractAlpha(string s){ string result; for (int i = 0; i < s.length(); i++) { if (isalpha(s[i])) { result += s[i]; } } return result;}bool passwordChecksOut(string username, string password){ string alphaPortion = extractAlpha(password); return !stringContains(toLowerCase(alphaPortion), toLowerCase(username));}STUDENT_TEST("various tests of extractAlpha() function"){ EXPECT_EQUAL(extractAlpha("sean"), "sean"); EXPECT_EQUAL(extractAlpha("sean11"), "sean"); EXPECT_EQUAL(extractAlpha("1sean"), "sean"); EXPECT_EQUAL(extractAlpha("s1ean"), "sean"); EXPECT_EQUAL(extractAlpha("s1e1a1n"), "sean"); EXPECT_EQUAL(extractAlpha("s9e$a***&n"), "sean"); EXPECT_EQUAL(extractAlpha(""), ""); EXPECT_EQUAL(extractAlpha("9$&"), "");}int main(){ runSimpleTests(ALL_TESTS); string username = "Sean"; string password = "s1e1a1n1'1s1p1a1s1s1w1o1r1d"; if (passwordChecksOut(username, password)) { cout << "Hooray!" << endl; } else { cout << "Oh no! Bad password." << endl; } return 0;} Abstract Data Types (ADTs): Introduction and Overview Next, we waded into a unit on ADTs (abstract data structures). The implementation details of an ADT might vary greatly from one language to another, and there are often many different ways to implement a particular ADT in any one language, as well. Having a set of data structures that provide an agreed-upon model for how data is stored and manipulated means we can: (a) have a common language for discussing solutions to a wide range of problems with other people in our field (b) write code that is fairly comprehensible even when viewed by someone who isn't familiar with the specifics of the language it's written in (c) focus on problem-solving without getting bogged down in unnecessary, low(ish)-level implementation details As we explore ADTs initially, we will approach them from the client perspective. That is, we will act as consumers of ADTs that have been implemented for us in C++ with a focus on what those ADTs allow us to accomplish, without getting bogged down with the behind-the-scenes details of exactly how those ADTs are implemented. This will rapidly open up entire vistas of new problems that we can solve with code. We will, however, return to the implementation details of these data structures later this quarter. Vector Overview The first ADT we explored was the Vector: A vector is a type of list that expands and shrinks automatically as new elements are added or removed. The elements in a vector are inherently ordered. Each element in a vector is assigned a position relative to the others. The elements in a vector are indexed 0 through n - 1 (where n is the number of elements in the vector). The vector is a homogenous container. All the elements in a given vector must be of the same type. Underlying the Vector from the Stanford C++ Libraries is an array, which means: Elements are stored in contiguous blocks in memory. We can quickly access the element at any given index in the the vector. The vector we are describing is, of course, analogous to a list in Python or an ArrayList in Java. This ADT is ubiquitous in the real world. One place where you see a vector in action pretty much daily is if you open multiple tabs in your web browser. Tabs have an inherent ordering, and the size of the underlying data structure used to keep track of them can grow and shrink as you open and close more tabs. To create a vector, we must include the following library: #include "vector.h" The syntax for creating a vector is as follows: Vector< DATA_TYPE > VARIABLE_NAME ; Optionally, we can provide an initial list of elements that the vector contains: Vector< DATA_TYPE > VARIABLE_NAME { ELEMENT_1 , ELEMENT_2 , ..., ELEMENT_N }; (Important note!) C++ has a built-in vector that we will not be using this quarter. The C++ vector has a lowercase 'v'. The vector from the Stanford C++ Libraries has an uppercase 'V'. Vector Functions and Sample Code myVector[i] accesses the element at index i. Additionally, we have the following functions: Member Function Description size() returns number of elements in the vector isEmpty() returns true if the vector is empty, false otherwise add(value) adds a new element to the end of the vector insert(index, value) inserts the value before the specified index, moving the values after it up by one index remove(index) removes the element at the specified index, moving the rest of the elements down by one index clear() removes all elements from the vector . . . For an exhaustive list, see: Stanford Vector class Here's a slightly fleshed-out version of the example we saw in class today: #include <iostream>#include "console.h"#include "vector.h"using namespace std;int main(){ Vector<int> v {15, 20, 18}; // A this point, we have: // +----+----+----+ // | 15 | 20 | 18 | // +----+----+----+ // 0 1 2 // We have a size() function that tells us how many elements are in a vector, // and we can access individual elements using VARIABLE_NAME[INDEX]. Putting those // together, we can loop through the vector and print its contents: for (int i = 0; i < v.size(); i++) { cout << "index " << i << ": " << v[i] << endl; } // We can also check whether a vector is empty using the isEmpty() function: if (v.isEmpty()) { cout << "Empty vector." << endl; } // The add() function adds an element to the end of the vector. v.add(33); // We now have: // +----+----+----+----+ // | 15 | 20 | 18 | 33 | // +----+----+----+----+ // 0 1 2 3 // The insert() function adds an element at a given index, first scooting over // all elements at and to the right of that index in order to make room for the // new element. v.insert(2, 90); // We now have: // +----+----+----+----+----+ // | 15 | 20 | 90 | 18 | 33 | // +----+----+----+----+----+ // 0 1 2 3 4 // The remove() function removes the element at a given index, then scoots over // all elements to the right of that index so as not to leave a gap in the vector. v.remove(0); // We now have: // +----+----+----+----+ // | 20 | 90 | 18 | 33 | // +----+----+----+----+ // 0 1 2 3 return 0;} Runtime Comparison: add(value) vs. insert(0, value) We saw that inserting at the beginning of a vector with v.insert(0, value) forces us to spend time scooting over every single element that the vector already contains. Repeatedly inserting at the beginning of a vector, then, is dangerously slow. Each new insertion must perform more work than the last, because there is one more element to scoot over each time. The v.add(value) function is, in comparison, quite fast. It just plunks a new element onto the end of the vector. This occasionally causes the vector to quietly expand behind the scenes (a detail we will explore later this quarter), but is otherwise a fast operation. To demonstrate the enormous runtime disparity between repeated calls to v.insert(0, value) and v.add(value), I produced the following code and used TIME_OPERATION from our SimpleTest library to see how long vectorAdd() and vectorInsert() were taking on various input sizes: #include <iostream>#include "console.h"#include "SimpleTest.h"#include "vector.h"using namespace std;void vectorAdd(int size){ Vector<int> v; for (int i = 0; i < size; i++) { v.add(i); }}void vectorInsert(int size){ Vector<int> v; for (int i = 0; i < size; i++) { v.insert(0, i); }}PROVIDED_TEST("runtime comparison"){ int size = 500000; TIME_OPERATION(size, vectorAdd(size)); TIME_OPERATION(size, vectorInsert(size));}int main(){ runSimpleTests(ALL_TESTS); return 0;} We saw that the time it takes to execute vectorInsert() is EXPLOSiVE, and the difference between that and the time it takes to execute addInsert() is absolutely astounding -- especially as size increases. Our in-class experiments yielded the the following runtimes: size vectorAdd() runtime vectorInsert() runtime how much slower? 50,000 0.005s 0.086s 17.2x 500,000 0.029s 9.794s 337.8x Grid Overview We then saw the Grid ADT, which is effectively a rectangular array. You could conceive of it as a vector of vectors. Grids can be used to represent all kinds of things, including: spreadsheets (where element in a grid corresponds to a cell in a spreadsheet) game boards (e.g., an 8x8 grid of characters indicating locations of pieces on a chess board) images (a grid of color codes, one for each pixel in an image) ... and so many more Like a vector, the elements in a grid are ordered and indexed. A grid has some number of rows (horizontal) and columns (vertical). To create a grid, we must include the following library: #include "grid.h" The syntax for creating a vector is as follows: Grid< DATA_TYPE > VARIABLE_NAME ( NUM_ROWS , NUM_COLUMNS ); (Important note!) We must capitalize the 'G' in "Grid," just as we capitalize the 'V' in "Vector." (Key take-away!) We saw that this data structure is "row-major" because the elements within a row are clustered together in memory. If you can remember the phrase "row-major," you can remember that the row, being such a "major" aspect of the grid's structure, always comes before the column -- both when creating a grid and accessing individual elements within a grid. Grid Functions and Sample Code myGrid[i][j] accesses the element at row i, column j. Additionally, we have the following functions: Member Function Description numRows() returns the number of rows in the grid numCols() returns the number of columns in the grid resize(rows, cols) changes the dimensions of the grid and re-initializes all entries to their default values inBounds(row, col) returns true if the specified (row, col) position is in the grid, false otherwise . . . For an exhaustive list, see: Stanford Grid class Here's a fleshed-out version of the example we saw in class today: #include <iostream>#include "console.h"#include "grid.h"using namespace std;int main(){ Grid<int> g(3, 4); // Values in an integer grid are zeroed out by default. At this point, we have: // +----+----+----+----+ // 0 | 0 | 0 | 0 | 0 | // +----+----+----+----+ // 1 | 0 | 0 | 0 | 0 | // +----+----+----+----+ // 2 | 0 | 0 | 0 | 0 | // +----+----+----+----+ // 0 1 2 3 // We can update the value at row 2, column 3, like so (see corresponding // cell highlighted in the diagram below): g[2][3] = 18; // We now have: // +----+----+----+----+ // 0 | 0 | 0 | 0 | 0 | // +----+----+----+----+ // 1 | 0 | 0 | 0 | 0 | // +----+----+----+----+ // 2 | 0 | 0 | 0 | 18 | // +----+----+----+----+ // 0 1 2 3 // Print an entire grid. For each row, print the values in each column. for (int i = 0; i < g.numRows(); i++) { for (int j = 0; j < g.numCols(); j++) { cout << g[i][j]; // If not the last element in this row, print a comma and a space. if (j != g.numCols() - 1) { cout << ", "; } } cout << endl; } return 0;} Passing Containers by Reference (Key take-away!) We often pass containers to functions by reference, even if we don't want a function to be able to modify the original container. That's because containers can store huge amounts of data, and passing them by value could therefore take up a lot of extra memory, on top of being a slow operation; copying the contents of a large container to a new location in memory takes more time than just establishing a reference. The syntax for passing a vector of integers by reference is as follows: void printVector(Vector<int>& v){ ...} Common Pitfalls A common pitfall with both vectors and grids is to access indices that are out of bounds. This will cause your program to crash spectacularly: #include <iostream>#include "console.h"#include "vector.h"using namespace std;int main(){ Vector<int> v {10, 20, 30}; v[3] = 40; return 0;} output: *** STANFORD C++ LIBRARY*** The Day04Lecture program has terminated unexpectedly (crashed)*** A fatal error was reported: Vector::operator []: index of 3 is outside of valid range [0..2]*** To get more information about a program crash,*** run your program again under the debugger. What's next? On Friday, we continue our discussion of ADTs. We will delve into the Stack and Queue containers from the Stanford C++ Libraries. If you're the sort of person who likes to read ahead, check out the course schedule in the Living Omni-Grid, which now lists what chapters/sections of the textbook we will cover in each lecture. Exam Prep 1. We wrote various tests for the extractAlpha() function in class today. Add to that code a separate STUDENT_TEST that contains a suite of test cases for the passwordChecksOut() function. What sorts of things would you test to ensure you have robust testing coverage for that function? 2. Write a function that takes a vector of integers as its only argument and prints it in the following format: +----+----+----+----+----+----+| 43 | 19 | 12 | 95 | 83 | 13 |+----+----+----+----+----+----+ 0 1 2 3 4 5 The function signature is: printVector(Vector<int>& v) To simplify the problem, you may assume all the integers in the vector have exactly two digits. Additional challenge (this is fairly advanced; don't worry too much about this one if you don't have time): How could you ensure when printing the contents of a vector that the largest box has exactly enough space for the largest integer in the vector to be surrounded by one space on either side, and all other boxes have the same amount of space, with each integer being centered within its cell to the extend possible? For example: +------+------+------+------+------+------+| 43 | 1 | 9 | 129 | 5821 | 3 |+------+------+------+------+------+------+ 0 1 2 3 4 5 3. In the previous problem, why would we pass the vector by reference if we have no intention of modifying it in the printVector() function? 4. As always, see the following resources for additional practice problems and reinforcement of this material: The course reader (free PDF available online; see readings listed at the top of today's notes). Today's lecture quiz. Assignment 1. Problems covered in section.
https://cs106b.stanford.edu/lectures/03-strings/
In today's lecture, we explore operations on the C++ string datatype. Readings: Text 3.1-3.7 Lecture quiz on Canvas Lecture video on Canvas Lecture Video Contents 0. A Note About Notations 1. Announcements 2. Common Pitfall with the || Operator 3. Void Functions 4. Function Placement and Functional Prototypes 5. Passing Parameters and Returning Values from Functions 6. Pass-by-Value Functions 7. Supplementary; Please Review A Slight Diversion: Variable Scope 8. Pass-by-Reference Functions 9. Supplementary; Please Review Qt Creator's Indication of Pass-by-Reference 10. ASCII Characters (and Typecasting!) 11. Magic Numbers 12. The Nature of Strings in C++ 13. C++ String Member Functions 14. Stanford C++ String Library (strlib.h) 15. Accessing (and Modifying) Individual Characters in Strings 16. Looping Through Strings 17. C++ Character Processing Library (cctype) 18. Supplementary; Please Review Character Processing: Additional Example 19. C++'s Two Types of Strings 20. Common Pitfall with Strings in C++ 21. What's next? 22. Exam Prep A Note About Notations Throughout today's notes, there are a few paragraphs and examples labeled (Not covered in lecture.) Those are supplemental notes designed to enrich your understanding of the material. Reviewing them is strongly recommended. There are also entire sections of notes that have a Supplementary; Please Review tag on their section titles. Those are items that are slightly more critical for you to review, which we did not have time to discuss in class today. Announcements Please be sure to use Ed where appropriate and to the extent possible to help us avoid this situation. A0 is due tonight at 11:59 PM. Q0 (Syllabus Quiz) is due tonight at 11:59 PM. We do not anticipate being available to help with quiz questions this evening. Section sign-up is due Sunday at 5 PM. Note that assignments not made on a first-come, first-served basis. You have two quizzes due next Wednesday (Jan. 17) at 11 AM (30 mins prior to lecture). This is a batch deadline that covers this week's lecture quizzes. Please create a system to help you stay on top of deadlines throughout the quarter, and be mindful of the unconventional time for quiz deadlines. Today's lecture quiz is set to open at 2 PM so I have time to run to my office and modify it if needed after lecture and office hours.) There is no LaIR this Sunday, but we will have LaIR next Monday, despite the holiday. We generally cancel LaIR the night before each holiday. A1 unlocks tonight (probably around 5 PM) and is due the Monday after next (Jan. 22) at 11:59 PM. Please consider pushing through most of it ASAP. There are a few pieces toward the end of it that rely on next Wednesday's lecture, and you don't want to wait until next Wednesday to start the whole thing. Section starts this week! You will receive a notification early next week about your lecture assignment. Once those are pushed out, you will be able to make adjustments in Paperless. Common Pitfall with the || Operator We picked right back up today with conditional statements and Boolean operators. In the following example, the cout statement is executed because C++ considers the value 2 to be true. (In fact, C++ considers all values to be true, other than 0 and false.) If we want to check whether a variable is equal to one value or another, we need to apply the == operator twice. #include <iostream>#include "console.h"using namespace std;int main(){ int numCupcakes = 5; if (numCupcakes == 1 || 2) // Yikes! This evaluates to true! { cout << "Uh oh! We're running low on cupcakes!" << endl; } return 0;} Here's the correct version: #include <iostream>#include "console.h"using namespace std;int main(){ int numCupcakes = 5; if (numCupcakes == 1 || numCupcakes == 2) // Fixed! { cout << "Uh oh! We're running low on cupcakes!" << endl; } return 0;} Void Functions In this section, we define a few functions other than main() and explore return types, return values, and parameters. If a function takes no parameters, we simply leave the parameter list within its parentheses blank. If we write a function that does some work for us, but which we never expect to produce a meaningful value at the end of its execution, then it needn't return a value at all. In this case, we give the function a return type of void, like so: #include <iostream>#include "console.h"using namespace std;void greet(){ cout << "hello :)" << endl;}int main(){ greet(); return 0;} A void function does not require a return statement. We return to the function that called it when we reach the end of the function's definition. (Not covered in lecture.) Optionally, if we wish to leave a void function before its final line, we can simply return (without specifying a return value), like so: #include <iostream>#include "console.h"using namespace std;void processCupcakes(int numCupcakes){ if (numCupcakes < 0) { cout << "Invalid number of cupcakes." << endl; return; } // One can imagine doing something useful with numCupcakes here. // If we pass a negative value to this function, the following line // will not print. cout << "We reached the last line of the function." << endl;}int main(){ processCupcakes(-3); return 0;} Function Placement and Functional Prototypes I mentioned again today that the C++ compiler processes your code line-by-line, starting at the very first line. A consequence of that is that if the compiler encounters a function call for a function that hasn't been defined yet (or for which we have not yet written the requisite #include statement), it goes kaput. For example: #include <iostream>#include "console.h"using namespace std;int main(){ cout << square(5) << endl; // ERROR: square() function not yet defined. return 0;}int square(int x){ return x * x;} What's happening above is that when we hit the cout line, C++ goes, "What's this square() function? Never heard of it." And it stops trying to compile the program in protest. There are two ways around this: Move the definition of the square() function above main(). Introduce a functional prototype! A functional prototype is just a function signature with a semicolon. A function signature is that first line of your function's definition that gives the return type, function name, and parameter list. Here's a functional prototype in action: #include <iostream>#include "console.h"using namespace std;// functional prototypeint square(int x);int main(){ cout << square(5) << endl; // This is okay now. return 0;}int square(int x){ return x * x;} This time, when C++ reaches the cout line, even though it doesn't have a definition for the square() function, it has a good idea (from having already seen the functional prototype) of how that function should be called, including the number and type of arguments it takes and its return type. It checks out the cout line and says, "Alrighty. I don't know how the square() function works yet, but I do know that the way you're calling it here fits with how I expect it to be called. Good work." It then carries on and successfully compiles the program. (Not covered in class.) Note that if we never defined the square() function, the program would not compile, even if we had a functional prototype. The compiler would fail at the very end of the file, when it realized there was no more code to process and it never got a definition for square(): #include <iostream>#include "console.h"using namespace std;// functional prototypeint square(int x);int main(){ cout << square(5) << endl; return 0;}// ERROR: Reached end of code without ever defining square() function. Passing Parameters and Returning Values from Functions The following square() function is designed to take a single integer parameter, x, and return x2. To set this function up to accept a parameter, we give a full declaration for that variable within the parentheses in the function signature (the line with the function's name, return type, and parameter list). #include <iostream>#include "console.h"using namespace std;// We pass an integer to this function, and it returns an integer.int square(int x){ return x * x;}int main(){ square(5); return 0;} However, when we run the above program, nothing gets printed to the screen. That's because we never did anything in main() with the return value of our call to square(5). We must capture that return value. Here are two ways to print the return value to the screen: #include <iostream>#include "console.h"using namespace std;// We pass an integer to this function, and it returns an integer.int square(int x){ return x * x;}int main(){ // Option 1: Send the return value of square(5) directly to cout. cout << square(5) << endl; // Option 2: Store the return value in a variable and print that. int result = square(5); cout << result << endl; return 0;} The program now produces the following output: 2525 (Not covered in lecture.) If we want our function to print the result directly, we could write it as follows. Notice that the modified behavior of this function is reflected both in its modified name and the void return type: #include <iostream>#include "console.h"using namespace std;void printSquare(int x){ cout << x * x << endl;}int main(){ printSquare(5); return 0;} Pass-by-Value Functions We then explored this example of a pass-by-value function and saw that when we call foo(n), that creates an additional n variable in memory that is separate from the n variable in main(): pass-by-value approach: #include <iostream>#include "console.h"using namespace std;void foo(int n){ n++;}int main(){ int n = 3; foo(n); // This prints 3. The ++ operator in foo() only increments foo()'s local copy // of n -- not our n variable back in main(). cout << n << endl; return 0;} Here's what's happening in memory. Notice that main() and foo() have separate n variables: main()+----------------+| n || +-------+ || | 3 | || +-------+ |+----------------+foo()+----------------+| n || +-------+ || | 4 | || +-------+ |+----------------+ output: 3 Supplementary; Please Review A Slight Diversion: Variable Scope Variables only exist within the code blocks where they are declared -- or, in the event that you declare a variable in the header of a for-loop, that variable only exists within the loop. We refer to the regions of code that can refer to a particular variable as the variable's scope. We saw an example of that above when declaring an integer n in two separate functions. Here is another example: #include <iostream>#include "console.h"using namespace std;int main(){ for (int i = 0; i < 5; i++) { int q = 5; cout << i << endl; } cout << "i is: " << i << endl; // ERROR: undeclared variable cout << "q is: " << q << endl; // ERROR: undeclared variable return 0;} In the code above, we say that the i and q variables only exist within the scope of the for-loop. To refer to them outside the for-loop, they would have to be declared elsewhere. For example: #include <iostream>#include "console.h"using namespace std;int main(){ int i; int q; for (i = 0; i < 5; i++) { q = 5; cout << i << endl; } cout << "i is: " << i << endl; // OKAY cout << "q is: " << q << endl; // OKAY return 0;} Pass-by-Reference Functions We then saw an example of a pass-by-reference function in C++. Here, we have turned foo()'s n variable into a reference by appending an ampersand (&) to its data type. In this example, foo()'s n is masquerading as a normal integer, but under the hood, it's actually acting as a portal to n back in main(). In this way, it refers to main()'s n variable (hence the term "reference"). When we execute the n++ line, the program actually goes back to main() and modifies the value of n that we find there. pass-by-reference approach: #include <iostream>#include "console.h"using namespace std;// This is now a pass-by-reference function. Note the addition of the ampersand.void foo(int& n){ n++;}int main(){ int n = 3; foo(n); // This prints 4. The ++ operator in foo() increments n back in main(), since // foo()'s copy of n is tied directly to this one. cout << n << endl; return 0;} Here's what's happening in memory. Notice that foo()'s n variable now acts as a wormhole to main()'s n variable: main()+----------------+| n || +-------+ || | 4 | || +-------+ |+------&uarr;---------+ |foo() |+------|---------+| n | || +---|---+ || | | || +-------+ |+----------------+ output: 4 There are at least two great reasons to use references in C++: They help us get around the fact that functions in C++ only return a single value. If we want to write a function that produces more than one value that we're interested in capturing, references help us do that. Some examples include: A swap() function that takes two integers by reference and results in them swapping values. This is a common operation in all kinds of algorithms -- especially sorting algorithms, which we'll explore later this quarter. A solveQuadratic() function that takes three integers by value (a, b, and c, the coefficients for the quadratic equation) and two integers by reference (result1 and result2) and uses those references to communicate the roots of the equation back to the calling function. See Section 2.5 of the course textbook for the implementation. They can be used to save time and space when working with large amounts of data. For example, if we have a string that contains 1 GB of text, passing it to a function by value causes us to use another GB of memory to create a separate copy of it, and it takes time to copy that GB of text from one variable to another. In contrast, if we pass the string by reference, we use a tiny amount of memory (typically just 64 bits!) to establish the tether between that reference variable and the original variable being referenced. Because we use so little memory, the transaction involved is very fast, too. The other example we saw involved a treasure hunt. A pass-by-value approach to raiding a series of treasure hoards makes no sense, as it does not empty out the original hoards in memory: pass-by-value approach: #include <iostream>#include "console.h"using namespace std;int treasureHunt(int h1, int h2, int h3){ int myTreasarrrrrr = 0; myTreasarrrrrr += h1; h1 = 0; myTreasarrrrrr += h2; h2 = 0; myTreasarrrrrr += h3; h3 = 0; return myTreasarrrrrr;}int main(){ int hoard1 = 350; int hoard2 = 43; int hoard3 = 5003; int totalBooty = treasureHunt(hoard1, hoard2, hoard3); cout << "Total Booty: " << totalBooty << endl << endl; // We've pirated and pillaged, but these hoards don't reflect that. cout << "hoard1: " << hoard1 << endl; cout << "hoard2: " << hoard2 << endl; cout << "hoard3: " << hoard3 << endl; return 0;} output: Total Booty: 5396hoard1: 350hoard2: 43hoard3: 5003 A minor adjustment turns this into a pass-by-reference function and gives us the desired behavior of wiping out the treasure hoards as we pillage: pass-by-reference approach: #include <iostream>#include "console.h"using namespace std;int treasureHunt(int& h1, int& h2, int& h3){ int myTreasarrrrrr = 0; myTreasarrrrrr += h1; h1 = 0; myTreasarrrrrr += h2; h2 = 0; myTreasarrrrrr += h3; h3 = 0; return myTreasarrrrrr;}int main(){ int hoard1 = 350; int hoard2 = 43; int hoard3 = 5003; int totalBooty = treasureHunt(hoard1, hoard2, hoard3); cout << "Total Booty: " << totalBooty << endl << endl; // These are now zeroed out. cout << "hoard1: " << hoard1 << endl; cout << "hoard2: " << hoard2 << endl; cout << "hoard3: " << hoard3 << endl; return 0;} output: Total Booty: 5396hoard1: 0hoard2: 0hoard3: 0 Supplementary; Please ReviewQt Creator's Indication of Pass-by-Reference Note that when we call a function, Qt Creator uses italics to indicate whether any parameters are pass-by-value. Unitalicized parameters are pass-by-value. (See calls to treasureHunt() above.) I did not mention this in class today because my interface wasn't doing that for some reason. (I apparently have some Qt Creator things to work on this weekend....) ASCII Characters (and Typecasting!) We then explored the ASCII values underlying the char data type in C++. ASCII is an international standard for character representation. To force C++ to show us the ASCII values underlying specific characters, I used C++'s "function-style" typecast, which involved placing a char variable in the parentheses of int(...) to cajole C++ into treating it as an int within that context. Furthermore, we saw that because chars in C++ are actually just ints behind the scenes, we can apply comparison and arithmetic operators to them. For example: #include <iostream>#include "console.h"using namespace std;int main(){ for (char ch = 'a'; ch <= 'z'; ch++) { // typecast! cout << ch << " (" << int(ch) << ")" << endl; } return 0;} output: a (97)b (98)c (99)d (100)e (101)f (102)g (103)h (104)i (105)j (106)k (107)l (108)m (109)n (110)o (111)p (112)q (113)r (114)s (115)t (116)u (117)v (118)w (119)x (120)y (121)z (122) Magic Numbers I then presented the challenge of printing ordinal numbers 1 through 26 next to those characters. A simple tweak is as follows (see highlighted code): #include <iostream>#include "console.h"using namespace std;int main(){ for (char ch = 'a'; ch <= 'z'; ch++) { cout << ch << " (" << int(ch) - 96 << ")" << endl; } return 0;} output: a (1)b (2)c (3)d (4)e (5)f (6)g (7)h (8)i (9)j (10)k (11)l (12)m (13)n (14)o (15)p (16)q (17)r (18)s (19)t (20)u (21)v (22)w (23)x (24)y (25)z (26) A problem with this approach is that we're hard-coding an integer that to the average ready might seem so mysterious and opaque that they would look at the code and say, "What does that number mean? How does that even work? It looks like magic!" We call such literal values "magic numbers," and it's considered best practice to avoid them. You might be able to get away with a really obvious literal in your code (such as the number 26 when working with the alphabet), but the 96 is rather obscure. We rewrote the code as follows, replacing the magic number with ('a' - 1): #include <iostream>#include "console.h"using namespace std;int main(){ for (char ch = 'a'; ch <= 'z'; ch++) { cout << ch << " (" << int(ch) - ('a' - 1) << ")" << endl; } return 0;} The Nature of Strings in C++ We then dove into the nature of strings in C++ and saw two key points on that topic: 1. Strings are arrays of characters. At its core, a string is really just an array of characters. That is, a string is a block of characters that are contiguous in memory that are indexed from 0 through (n - 1), where n is the overall number of characters in the string. For example, the string "hello there" is represented as follows: +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+| 'h' | 'e' | 'l' | 'l' | 'o' | ' ' | 't' | 'h' | 'e' | 'r' | 'e' |+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+ 0 1 2 3 4 5 6 7 8 9 10 (Important Note) Recall that strings in C++ must be given in double quotes, not single quotes. We only use single quotes for single characters. 2. Strings are objects (not primitive data types). I also pointed out that when we declare a string variable in the Qt Creator, the default color for the word string is different from the color used for int, float, double, and char. That's because strings in C++ are fundamentally different from the latter data types, which are called primitive types. Primitive types form the foundation for all other data types in C++. A string, in contrast, is an object. We will explore objects in more detail closer to the mid-term. For now, I'd like you to know that this means a string is a bundle -- not just of the character array representing that string, but also of a bunch of built-in functions called member functions that we can access by using the dot operator (.) on one of our strings. For example: #include <iostream>#include "console.h"using namespace std;int main(){ string s = "hello there"; // Notice that we are not passing s to a length function. Rather, we use the dot // operator on the s variable to call a length() function that is packed up with // the string and which gives us the length of that string (11, as there are 11 // characters in "hello there"). (The space counts a character.) cout << s.length() << endl; return 0;} output: 11 C++ String Member Functions String objects in C++ have a ton of built-in functions. To use these functions, we technically have to #include <string>. However, including either <iostream> or "console.h" actually indirectly causes the string library to be imported behind the scenes, so we don't need to do that directly in order for our code to compile and run. Here's an index of some of the most handy functions we can call using a string's dot operator in C++: Member Function Description s.append(str) add text to the end of a string s.compare(str) return -1, 0, or 1 depending on relative ordering s.erase(index, length) delete text from a string starting at given index s.find(str)s.rfind(str) return first or last index where the start of str appears in this string (returns string::npos if not found) s.insert(index, str) add text into string at a given index s.length()s.size() return number of characters in the string s.replace(index, len, str) replace len chars at given index with new text s.substr(start, length)s.subsr(start) return a new string with the next length chars beginning at start (inclusive); if length is omitted, grabs till end of string In class, we saw an example in class of the substr() function in action: #include <iostream>#include "console.h"using namespace std;int main(){ string s = "hello there"; // Start at index 1 in the string and pull out the first 4 characters there. cout << s.substr(1, 4) << endl; return 0;} output: ello Stanford C++ String Library (strlib.h) Similarly, the Stanford C++ string library has some powerful functions for processing strings. This library is really well documented and fairly straightforward. Function Name Description endsWith(str, suffix)startsWith(str, prefix) returns true if the given string begins or ends with the given prefix/suffix text integerToString(int)realToString(double)stringToInteger(str)stringToReal(str) returns a conversion between numbers and strings equalsIgnoreCase(s1, s2) returns true if s1 and s2 have same chars, ignoring case toLowerCase(str)toUpperCase(str) returns an upper/lowercase version of a string (pass-by-value!) trim(str) returns string with surrounding whitespace removed (Super Handy Productivity Tip) If you #include "strlib.h" in a Qt Creator project, you can CTRL+CLICK on strlib.h to go into that file and see a list of functional prototypes with descriptions of what those functions do. Alternatively, you can click over to the Resources page on the course website, click "Stanford Library documentation," then click strlib.h on that page. We saw the following example: #include <iostream>#include "console.h"#include "strlib.h"using namespace std;int main(){ string s = "hello there"; toUpperCase(s); cout << s << endl; return 0;} output: hello there Notice that this does not convert s to uppercase! That's because toUpperCase() is a pass-by-value function. We can determine that in the Qt Creator simply by observing that when we call toUpperCase(s), the s parameter does not get italicized. toUpperCase(s) returns the uppercase version of the string it receives. To get this example working, we need to store that return value somewhere. Here's the working version of this example: #include <iostream>#include "console.h"#include "strlib.h"using namespace std;int main(){ string s = "hello there"; s = toUpperCase(s); cout << s << endl; return 0;} output: HELLO THERE Accessing (and Modifying) Individual Characters in Strings We saw that we can access (and change!) individual characters in C++ strings. This is unusual compared to Python and Java, where we can't just tweak one character. If we want to modify a Python or Java string, we need to call functions or apply operators that ultimately build new strings in the background. We say C++'s strings are mutable (able to be changed), whereas Python and Java strings are immutable. If a string appears to be changing in Python or Java, it's really not; what you're seeing is really a new, separate string. Along those lines, we examined the following code: #include <iostream>#include "console.h"using namespace std;int main(){ string s = "hello"; cout << s << endl; // This changes the character at index 0. I read "s[0]" out loud as "s-sub-zero." s[0] = 'Y'; cout << s << endl; // We can concatenate a single character to a string using the + operator. We know // the w below is just a character (not a string) because it's in single quotes. s += 'w'; cout << s << endl; // We can also concatenate an entire string. s += " squashes"; cout << s << endl; return 0;} output: helloYelloYellowYellow squashes Looping Through Strings We then reviewed two ways to loop through strings: #include <iostream>#include "console.h"using namespace std;int main(){ string s = "hello"; // We can loop through a string using a for-loop. for (int i = 0; i < s.length(); i++) { cout << i << ": " << s[i] << endl; } // We can also use a for-each loop (aka "range-based loop"), but this approach // doesn't give us a handy variable to tell us what index we're at in the string. cout << endl; for (char ch : s) { cout << ch << endl; } return 0;} output: 0: h1: e2: l3: l4: ohello C++ Character Processing Library (cctype) We talked briefly about the cctype library is chock full of char processing functions, almost all of which take a single char argument and are named isXXXXX() (where XXXXX is some five-letter string indicating what type of character the function is checking for). For your reference, here are the functions from that library. Please be sure to look over these on your own time so you have an idea of what functions are available to you as you start working on your programming assignments for this course: Member Function Description isalnum(ch) checks if a character is alphanumeric isalpha(ch) checks if a character is alphabetic islower(ch) checks if a character is a lowercase alphabetic character isupper(ch) checks if a character is an uppercase alphabetic character isdigit(ch) checks if a character is a digit isxdigit(ch) checks if a character is a hexadecimal character iscntrl(ch) checks if a character is a control character isgraph(ch) checks if a character is a graphical (i.e., visible) character isspace(ch) checks if a character is a space character (typically tab or space) isblank(ch) checks if a character is a blank character isprint(ch) checks if a character is a printing character according to locale ispunct(ch) checks if a character is punctuation (visible non-alnum/non-space) toupper(ch) converts a character to uppercase (pass-by-value!) tolower(ch) converts a character to lowercase (pass-by-value!) In class, we saw an example similar to the following that illustrated the use of isalpha(): #include <cctype>#include <iostream>#include "console.h"using namespace std;int main(){ string s1 = "yellow"; string s2 = "$assy"; // Should print "yes" because s1[0] ('y') is an alphabetic character. if (isalpha(s1[0])) { cout << "yes" << endl; } else { cout << "no" << endl; } // Should print "no" because s2[0] ('$') is not an alphabetic character. if (isalpha(s2[0])) { cout << "yes" << endl; } else { cout << "no" << endl; } return 0;} Supplementary; Please ReviewCharacter Processing: Additional Example Here is an additional example of a character processing function for you to review. It prints all the lowercase alphabetic characters from a string. This is more sophisticated than some of the chunks of code we have written so far in class. Can you see how this is working? #include <iostream>#include "console.h"using namespace std;int main(){ string password = "p4ssw0rd"; string alphaPortion; for (int i = 0; i < password.length(); i++) { // checks whether password[i] is a lowercase char if (password[i] >= 'a' && password[i] <= 'z') { alphaPortion += password[i]; } } cout << alphaPortion; return 0;} output: psswrd (Important Note) (Not covered in class.) We have talked a bit about the fact that uninitialized variables are problematic in C++. That doesn't apply to C++'s string variables, though. Those actually get auto-initialized to an empty string (double quotes with nothing -- not even a space -- between them: "") if you don't give them some other value. So, the use of the uninitialized alphaPortion variable above is not problematic. A variation on this approach relies on the isalpha() function from C++'s cctype library: #include <iostream>#include "console.h"using namespace std;int main(){ string password = "p4ssw0rd"; string alphaPortion; for (int i = 0; i < password.length(); i++) { if (isalpha(password[i])) { alphaPortion += password[i]; } } cout << alphaPortion << endl; return 0;} output: psswrd C++'s Two Types of Strings I mentioned this briefly toward the end of class today -- not because it's super important for you to have a deep understanding of this, but because I want you to have a reference on this topic in case you run into problems with this while working with strings in your programming assignments this quarter: C++ actually has two types of strings. We have seen C++'s string variable type, but any time we type a string literal (i.e., a hard-coded string in double quotes), we are actually getting a C-style string. Applying operators to two C-style strings is dangerous and can lead to code that won't compile -- or worse: wonky, unexpected results. However, we can apply operators to two strings if at least one of them is a C++ style string, and we can always get a C++ style string by assigning a C-style string to a C++ string variable. Here are some examples to clarify: #include <iostream>#include "console.h"using namespace std;int main(){ // BAD! Before we do the "=" operation, we resolve the right-hand side of that // operator. That involves trying to apply the "+" operator to two string literals, // which are C-style strings. C++ will not even allow this to compile. string s1 = "abc" + "xyz"; // OKAY. We can assign C-style strings directly to C++ string variables. string s2 = "abc"; string s3 = "xyz"; // OKAY. Both s2 and s3 are C++ style strings. We can apply the "+" operator // to two C++ strings to concatenate them. string s4 = s2 + s3; cout << s4 << endl; // OKAY. This works, too! The right-hand side of the "=" operator gets resolved // first, and since s5 + "hello" involves at least one C++ style string, the // operation is good to go. string s5 = "hello"; string s6 = s5 + " there"; cout << s6 << endl; // OKAY. Same as above, but with (C + C++) instead of (C++ + C). string s7 = " there"; string s8 = "hello" + s7; cout << s8 << endl; // OKAY. There is a function called string() that we can use to create a C++ // style string out of a C-style string. As long as we apply it to at least one of // the C-style strings below, we end up with at least one C++ style string, and we // are then in the clear to use the concatenation operator. string s9 = "hello" + string(" there"); cout << s9 << endl; // OKAY. Similarly, C++ allows us to typecast a C-style string to a C++ string. string s10 = "hello" + (string)" there"; cout << s10 << endl; return 0;} Common Pitfall with Strings in C++ (Not covered in class.) C++ lets you access invalid indices when playing with strings. This can cause all kinds of wonky things to happen in your programs. For example: #include <iostream>#include "console.h"using namespace std;int main(){ string s = "hello"; // UH OH! Accessing invalid index! Who knows what will happen? cout << s[10] << endl; return 0;} output (which may be different when you run this on your system): Going far enough out of bounds in your string can actually cause a program to crash: #include <iostream>#include "console.h"using namespace std;int main(){ string s = "hello"; // UH OH! Accessing invalid index! Who knows what will happen? cout << s[100000000] << endl; return 0;} output (which may be different when you run this on your system): *** The Day03Lecture program has terminated unexpectedly (crashed)*** A segmentation fault (SIGSEGV) occurred during program execution This error indicates your program attempted to dereference a pointer to an invalid memory address (possibly out of bounds, deallocated, nullptr, ...)*** To get more information about a program crash,*** run your program again under the debugger. What's next? There are no classes on Monday. When we return on Wednesday, we'll talk briefly about testing (including the SimpleTest framework in the Stanford C++ Libraries) and then delve into two abstract data types that are implemented in the Stanford libraries: Vector and Grid. Exam Prep Your biggest training grounds for the material we're covering in lecture will be (a) your weekly section meeting, where you'll get more detailed explanations of some of these topics as well as hands-on experience with practical applications, and (b) the assignments, which are constructed to guide you through the material and help you ramp up your understanding quite quickly. Nonetheless, I will occasionally post additional practice problems for those who are looking for even more reinforcement and hands-on experience or stepping stones to help work up to the week's assignment and/or section problems. 1. (Pass-by-Reference Functions) Write a pass-by-reference function called mySwap() that takes two integers and swaps their values. Your function should pass the test case provided below. What should the return type be? What types should we use for the function parameters? (Note: The function is called mySwap() because there is already a native swap() function in C++.) #include <iostream>#include "console.h"#include "SimpleTest.h"using namespace std;PROVIDED_TEST("basic test of swap() function with two integers"){ int a = 53; int b = 42; mySwap(a, b); EXPECT_EQUAL(a, 42); EXPECT_EQUAL(b, 53);}int main(){ runSimpleTests(ALL_TESTS); return 0;} Highlight for solution: #include <iostream>#include "console.h"#include "SimpleTest.h"using namespace std;// Note: Alternatively, we could put this below main() and// drop a functional prototype here.void mySwap(int& a, int& b){ int temp = a; a = b; b = temp;}PROVIDED_TEST("basic test of swap() function with two integers"){ int a = 53; int b = 42; mySwap(a, b); EXPECT_EQUAL(a, 42); EXPECT_EQUAL(b, 53);}int main(){ runSimpleTests(ALL_TESTS); return 0;} 2. (Pass-by-Reference Functions) Now that you have some practice with pass-by-reference functions from Exercise 1, see if you can close out the the notes and recreate the functionality of today's treasureHunt() function from scratch, without peeking back at the notes for assistance. 3. (Pass-by-Reference Functions) Trace through the following program by hand to see if you can determine the output it will produce. Then run compile and run the program to check your result. #include <iostream>#include "console.h"using namespace std;void mystery(int& b, int c, int& a){ a++; b--; c += a;}int main(){ int a = 5; int b = 2; int c = 8; mystery(c, a, b); cout << a << " " << b << " " << c << endl; return 0;} 4. Be sure to carefully review the notes labeled Supplementary; Please Review. There is an interesting character processing function you should look into, a brief note about how variable scope relates to loops, and a note about how the Qt Creator signals to users when they're passing variables to a function by reference. 5. Be sure to glance through the notes labeled (Not covered in lecture.) to enrich and/or solidify your understanding of some of the finer points of this material. Those extra nuggets of information might prove useful at some point this quarter. Looking for more practice problems? Be sure to consult the course reader linked at the top of today's notes.
https://cs106b.stanford.edu/lectures/02-cpp/
Introduction to Fundamentals of C++ Programming Readings: Text Ch. 1, 2.1-2.4 Lecture quiz on Canvas Lecture video on Canvas Lecture Video Contents 0. Preliminary Note 1. Announcements 2. Productivity Tip: Hotkeys 3. Preliminaries: Syntax vs. Semantics 4. Preliminaries: Compilation and Execution 5. Getting Started: The Blank Qt Project (and the return of "Hello, world!") 6. Two Types of Comments in C++ 7. A Brief Guide to Commenting 8. #include Directives 9. Namespaces 10. The main() Function 11. The main() Function is Special 12. Return Statements 13. The cout Stream 14. The endl String Manipulator 15. Variables and Data Types 16. Common Pitfalls with Variables 17. Uninitialized Variables 18. While Loops 19. The ++ Operator 20. Wonky Spacing 21. For Loops 22. For-Each Loops (Range-Based Loops) 23. Conditional (If-Else) Statements and Comparison Operators 24. Boolean Operators 25. Catch-up Topic Common Pitfall with the || Operator 26. Catch-up Topic Void Functions 27. Catch-up Topic Passing Parameters and Returning Values from Functions 28. Catch-up Topic Function Placement and Functional Prototypes 29. Catch-up Topic Variable Scope 30. What's next? 31. Exam Prep Preliminary Note Sections with the Catch-up Topic label in today's notes are topics that I covered in this lecture last quarter, but didn't have time to get to in class today. Womp womp. :( We'll cover those topics on Friday (in addition to a lot of other material), but we'll move through them rather briskly. Please consider reading those ahead of time. I'll leave them on this page for now, until we see how our topic coverage shakes out over the next few days. Announcements Here are some announcements from the top of class today (as well as some new ones): Upcoming deadlines: A0 due Friday 11:59 PM Syllabus Quiz due Friday 11:59 PM Section sign-up opens Thursday, due Sunday 5 PM A few of our SLs will be hosting a Qt Creator install help sesson tomorrow (Thursday) from 5 - 7 PM in Durand 353. See details in Clinton's Week #1 Announcements post on Ed. Your first quiz will unlock sometime tonight, and it will be due next Wednesday at 11 AM. Please be sure to carefully track all deadlines this quarter. It's up to you to keep on top of all deadlines, even if there are not always reminders of those deadlines in class. Productivity Tip: Hotkeys I mentioned today that learning hotkeys for a few common tasks is critical for maximizing your coding productivity. Here are a few I brought up at various points in class today: CTRL+R will compile and run your project. CTRL+I will fix up the indentation of any code you have selected/highlighted. Preliminaries: Syntax vs. Semantics Before diving into C++ basics, I defined the following terms: syntax: the rules for constructing grammatical statements in a language (whether a coding language or a natural language) semantics: meaning Supplementary information: Consider, for example, the following sentence: The Count of Monte Cristo is on the shelf by The Picture of Dorian Gray. There's a lot of stuff happening with that sentence, syntactically. The punctuation at the end of the sentence is part of the syntax, as is the italicization. The fact that we have a noun ("The Count of Monte Cristo"), followed by a verb ("is"), followed by a prepositional phrase ("on the shelf by 'The Picture of Dorian Gray'"), is also a matter of syntax. That is a grammatically sound sentence. The semantics of that sentence relate to its meaning. We know, for example, that there isn't some old count (i.e., a person) sitting on a shelf next to a picture, where the picture happens to be of some dude named Dorian Gray. Semantically, what the sentence actually conveys is that there's a book on the shelf, and it's next to another book. Why is this relevant? As I introduce you to different things you can do with the C++ programming language, I will generally introduce you to the syntax you have to follow (i.e., how to write lines of code that the compiler will be happy with) and the associated semantics (i.e., what that syntax does or means). Preliminaries: Compilation and Execution A compiler is a program that takes code and builds it into a program that we can run. When we hit CTRL+R in the Qt Creator, our code is first run through a compiler. If compilation is successful, the program then gets executed. This is distinct from Python, where we often have an interpreter that executes our code line-by-line as we go. Getting Started: The Blank Qt Project (and the return of "Hello, world!") After some preliminary definitions, we dove into C++ code. To kick that off, I went to the course homepage and downloaded the Blank Qt Project (also linked from the Resources page). This will be part of your normal process for creating new projects that use goodies from the Stanford C++ Library. Next, I plunked down the following code from Monday: #include <iostream>#include "console.h"using namespace std;int main(){ cout << "Hello, world!" << endl; return 0;} From there, we started exploring what was happening on each line of code. Two Types of Comments in C++ I used comments extensively today to help communicate new concepts. We saw that C++ supports two commenting styles: Firstly, we have what's called a block comment. If we type /*, then everything after that is considered a comment until we first encounter a */. For example: /* This is a comment! * This is also part of the same comment! * Qt Creator adds a star on each line for formatting purposes when we use this * type of comment.Even though we don't have a star at the beginning of this line, it's still part ofour comment! * When we hit the end of this line, the star-slash causes our comment to end. */#include <iostream>#include "console.h"using namespace std;int main(){ cout << "Hello, world!" << endl; return 0;} Secondly, we have what's called a single-line comment. If we type //, then everything after that is considered a comment until we reach the end of that line. For example: // This is a comment!// This is a comment, too, but the line below this one is not!#include <iostream>#include "console.h"using namespace std;int main(){ cout << "Hello, world!" << endl; // This is a comment, too! return 0;} A Brief Guide to Commenting We want you to comment your code throughout the quarter, but don't go overboard. Comments should be used to enhance the readability of your code. Avoid comments that point out fundamentals of the language that the grader will already know. For example: Warning! All the comments below are unnecessary and should be removed. Please do not look to these as examples of useful comments! // include statements#include <iostream>#include "console.h"using namespace std;// main functionint main(){ // prints "Hello, world!" to screen cout << "Hello, world!" << endl; return 0;} // end of function Below are some over-branching guidelines for writing helpful comments. Your SL will also give you feedback on comments when grading your assignments. In general, consider giving a high-level overview of any function you write whose purposes might not be immediately clear from its name. Say something about its input parameters, expected output, and return value (if applicable). Within your functions, rather than commenting every single line of code, give high-level comments that tell what chunks of code do. However: Avoid simply repeating things that are "obvious" in code, thereby making someone read your code twice (once in English and once in C++). I.e., avoid transliterating your code from C++ to English. Prefer comments that tell how/why something works rather than simply saying what something does, unless you're explaining the behavior of a chunk of code in a way that makes your code easier for a reader to digest. Try to use function names that are verb phrases, which therefore act as documentation of what your code is doing. (Avoid obscure function and variable names that would require us to add clarifying comments everywhere they appear.) Keep comments brief. An exception here is if you're writing a comment at the top of a sophisticated source file -- which is often a bit longer -- or documenting a particularly complex function. A good rule of thumb: Suppose you load up your code for an assignment five years from now, and you've lost the write-up for that assignment. What comments would help you quickly understand what you were doing with each of those functions? Another rule of thumb: If you find yourself really struggling to fix a bug in your code at some point, that might be a signal that you've found a complex bit of code that would be more clear if it had a concise comment. #include Directives In every language, we need to be able to import libraries of pre-written code. In Python and Java, we accomplish that with import statements. In C++, we use #include statements. The syntax for those is as follows: including standard system libraries: #include < LIBRARY_NAME > including user-defined libraries: #include " LIBRARY_NAME " The Stanford C++ Libraries we #include this quarter will be in "double quotes," as they are user-defined libraries that we have piled on top of the standard goodies that you normally get with C++. The standard C++ libraries will be in <angled brackets>. You needn't worry too much about this for now. In all your assignments, we will give you the #include statements you need so you don't have to hunt down the library for every single function you want to call. (Not mentioned in class.) These #include directives are different from the other statements we saw today in that they are not terminated with semicolons. When it comes to #include statements, C++ always just reads those until it hits the end of the line -- no semicolon needed. (Not mentioned in class.) I didn't mention this in class, but here's what we're using those particular libraries for: <iostream> gives us access to cout and endl "console.h" gives us a cute pop-up terminal for our program's output Namespaces (Important Note) You don't need to be super familiar with how namespaces work at this time. As long as you're comfortable writing using namespace std; in your programs, you're good to go. I'm including this section of notes because I never want to run the risk of leaving you frustrated, confused, or dissatisfied if you're the kind of person who loves to peek under the hood and really understand how everything is working. I personally find that being exposed to these sorts of details make me feel more comfortable using a new language. When we work on large software projects, we often import multiple libraries from various sources. One of the problems that arises there is that some libraries might have functions with the same names as one another. For example, a networking library that establishes connections to other computers on a network might have a createConnection() function, and a database library that establishes connections to databases stored on our machines might also have a createConnnection() function. If we build a project that relies on both those libraries and then call createConnection(), we need a way to determine which version of that function gets called. C++ uses namespaces to handle this issue. A namespace is just a named collection of functions (and other entities) that are grouped together. A networking library might articulate a net namespace, and a database library might articulate a db namespace. We would then call those createConnection() functions like so: net::createConnection();db::createConnection(); The features of C++ we'll be using this quarter are pretty much all defined in a namespace called std (for "standard"). That includes features of C++'s standard libraries as well as the Stanford C++ Libraries. For example, cout and endl are both in the std namespace. To use them, we could do this: #include <iostream>#include "console.h"int main(){ std::cout << "Hello, world!" << std::endl; return 0;} The problem is, we'll be using a lot of functions and other goodies from those libraries, and having to type std:: for each one of them will be a huge waste of time and lead to unnecessarily lengthy, complicated lines of code. To get around that, we issue the using namespace std; statement above our function definitions. That tells C++ to look in the std namespace for the library components we use to build our programs, without the need to type std:: in front of any of them. Here's the resulting change: #include <iostream>#include "console.h"using namespace std;int main(){ // removed both occurrences of std:: below cout << "Hello, world!" << endl; return 0;} If we get rid of both the using namespace std; statement and the std:: tags, our program will not compile: #include <iostream>#include "console.h"int main(){ // removed both occurrences of std:: below cout << "Hello, world!" << endl; return 0;} Because we've given no indication of what namespace to pull cout and endl from, the compiler gives us the following errors: error: 'cout' was not declared in this scope; did you mean 'std::cout'?error: 'endl' was not declared in this scope; did you mean 'std::endl'? The main() Function Next, we explored the definition of our program's main() function. In the math world, a function does three main things: It takes an input value (or, in some cases, multiple input values). It does some work. For example, the function f(x) = x2 multiplies x by itself (i.e., it squares x). It spits out a result. For example, for f(x) defined above, the result generated by f(5) is 25. Functions in C++ effectively do the same thing, but C++ doesn't like mystery or surprises when it comes to its functions' inputs and outputs. It wants us to say what type of parameter(s) we're going to pass to a function and what type of data a function will produce (called its return type). The syntax for defining a function is as follows: DATA_TYPE FUNCTION_NAME ( PARAMETERS ){ STATEMENT(S) } (Key Take-Away) Notice the need for opening and closing curly braces. In Python, we simply indent lines of code to signify that they make up the body of some function. In C++, we use a code block (a set of opening and closing curly braces that encapsulate lines of code). (Key Take-Away) In C++, whitespace (in most cases) is not for the compiler; it's for humans. Please be kind to humans. Use good spacing. (Style Requirement) Any time you open a new code block, the code within that block should be indented one level deeper than the braces themselves. All this information offers us context for what's going on in main(). We return to the idea of writing new functions toward the end of today's notes, as well. The main() Function is Special The C++ compiler goes line-by-line through our code, starting on the first line and working its way down. When we run a program that's written in C++, however, execution always begins in main(). That function gets executed automatically, without any need for us to call it manually. A program that doesn't have a main() function won't compile. Return Statements The syntax for returning a value from a function is as follows: return EXPRESSION ; The EXPRESSION can be any expression that evaluates to the appropriate return type for our function and can include, among other things, variables, arithmetic operations, hard-coded values ("literals"), and other function calls. (Key Take-Away) Recall that main() should always return 0 (zero) upon successful execution of a program. You can think of this as main()'s way of saying that it encountered zero errors. That value is sent back to the operating system and can be monitored and interpreted by other programs. We sometimes return non-zero values from main() if something goes awry and we want to signal to anyone listening that our program didn't accomplish what we wanted it to. The cout Stream cout is what we call a stream. By default, it acts as a direct line to our terminal. Anything we send to it with the << operator gets printed to the screen. We saw today three primary things we can send to cout: string literals (a hard-coded string that appears in double quotes in our code, such as "Hello, world!") variables endl Several examples are included throughout today's notes. The endl String Manipulator endl causes a newline character to print to the screen. Without it, all our output runs together. For example: #include <iostream>#include "console.h"using namespace std;int main(){ // Note the lack of endl in the following statements. cout << "Hello, world!"; cout << "CS106B is awesome, and so are you!"; return 0;} The output for that program is as follows: Hello, world!CS106B is awesome, and so are you! Here's the fix, with changes highlighted in orange (or is it peach?): #include <iostream>#include "console.h"using namespace std;int main(){ cout << "Hello, world!" << endl; cout << "CS106B is awesome, and so are you!" << endl; return 0;} Our output now becomes: Hello, world!CS106B is awesome, and so are you! Variables and Data Types Unlike Python, which is very flexible with variable usage, C++ requires us to formally declare every variable we want to use and give it a specific data type that cannot be changed after declaration. We saw today the following data types: data type keyword type description example(s) int integer (whole number) -3, 0, 1, 1051 float floating point number (real number) 3.14159 double floating point number (real number) 3.14159 char character (single glyph) 'q', 'P', '$' (requires single quotes) string string of characters "Hello, world!" (requires double quotes) bool Boolean true, false (no quotes) A variable declaration is a statement wherein we bring a new variable into existence and give it a data type. The syntax for that in C++ is: DATA_TYPE VARIABLE_NAME ; See examples below. Notice that we can mix string literals with variables in our cout statements, and we can output multiple variables with a single cout statement, as well: #include <iostream>#include "console.h"using namespace std;int main(){ int a = 5; char ch = 'q'; float f = 3.14159; double d = 3.14159; string s = "hello"; cout << "Hello, world!" << " " << a << endl; cout << ch << " " << f << " " << d << endl; cout << s << endl; return 0;} Side note: A double typically uses double the amount of memory that a float uses and can therefore store more digits after the decimal place. You do not need to know that for this class. That topic is explored further in CS107. Common Pitfalls with Variables Here are some common errors we see with variables: Undeclared variable. We cannot use a variable that has not been declared. This code will not compile. #include <iostream>#include "console.h"using namespace std;int main(){ a = 5; // ERROR: a is undeclared; we must give it a data type cout << a << endl; return 0;} Type mismatch. In this example, a was designed to hold an integer. We cannot set it equal to a string. #include <iostream>#include "console.h"using namespace std;int main(){ int a = 5; a = "hello"; // ERROR: type mismatch; a can hold an integer, not a string cout << a << endl; return 0;} Attempting to change a variable's data type. Once a variable is declared to be of a certain type, it cannot be redeclared with a different type. #include <iostream>#include "console.h"using namespace std;int main(){ int a = 5; string a = "hello"; // ERROR: a is already declared; cannot declare with new type cout << a << endl; return 0;} Redefinition of variables. Here, we are trying to create a twice. #include <iostream>#include "console.h"using namespace std;int main(){ int a = 5; int a = 7; // ERROR: a is already declared on the line above cout << a << endl; return 0;} If you want to change the value of a variable you've already declared, simply do it on another line without re-declaring the data type, like so: #include <iostream>#include "console.h"using namespace std;int main(){ int a = 5; a = 7; // OKAY cout << a << endl; return 0;} Uninitialized Variables In C++, variables are not auto-initialized for you. By default, if you don't assign a value to a variable, it contains garbage. (An exception here is string variables, which are empty by default.) Most C++ compilers will merrily allow you to compile code in which variables have not been initialized. The Qt Creator will not -- and so I (as someone who doesn't typically use an IDE when writing C++ code) was caught off guard the first time I went to compile the following in the Qt Creator, and it actually stopped me: #include <iostream>#include "console.h"using namespace std;int main(){ int a; int b; int c; cout << a << " " << b << " " << c << endl; // YIKES. Uninitialized variables. // Some compilers will let this compile despite the uninitialized variables! return 0;} While Loops We assume that everyone coming into this course has seen while loops before, and so I introduced the syntax rather quickly. Syntax: while ( CONDITION ){ STATEMENT(S) } Note that the parentheses around the condition are required. Example: #include <iostream>#include "console.h"using namespace std;int main(){ int i = 1; while (i < 5) { cout << i << endl; i++; } return 0;} In Python, we would have done something like this: // Python code! Not C++!i = 1while i < 5: print(i) i += 1 The ++ Operator Notice above that we used i++ instead of i += 1. It is so common to want to increment an integer variable by one that C++ has a dedicated operator (the ++ operator) to do just that. Wonky Spacing To reinforce that C++ doesn't worry too much about whitespace, I at one point showed that a program still compiles even if we do something totally wonky with our spacing, like this: #include <iostream>#include "console.h"using namespace std;int main(){ int i = 1; while (i < 5) {cout << i << endl; i++; } return 0;} We also saw that if we highlight a chunk of code with wonky spacing, the Qt Creator is able to fix the indentation for us. Hit CTRL+I to fix indentation (or, if you can't remember the shortcut, right click and find that option in the menu that pops up). (Not covered in class.) Similarly, although I did not cover this in class, C++ would compile the following: #include <iostream>#include "console.h"using namespace std;int main(){ int i = 1; while (i < 5) { cout << i << endl; i++; } return 0;} (Style Requirement) The above approach is difficult to read, and putting multiple statements on a single line is actually prohibited in our style requirements for programming assignments. For Loops C++ also has for-loops, although they are quite different from Python's for-loops. Here's the syntax: for ( INITIALIZATION_STATEMENT ; CONDITION ; POST_ITERATION_STATEMENT ){ STATEMENT(S) } Notice the need for semicolons between each of the three components of the for-loop. The initialization statement is executed exactly once (when we first hit the for-loop), the condition is evaluated before kicking off an iteration, and the post-incrementation statement is executed at the end of each iteration of the loop, right before re-evaluating the looping condition. Example: #include <iostream>#include "console.h"using namespace std;int main(){ for (int i = 1; i < 5; i++) { cout << i << endl; } return 0;} This for-loop is syntactically distinct from the while-loop above, but it is semantically the same (aside from the fact that the i variable is out of scope once we leave the for-loop, which we discussed at the very end of lecture). For-Each Loops (Range-Based Loops) This is a third type of loop that C++ offers. It's good for looping through all the elements in a container (such as all the characters in a string or all the elements in an array). We will see additional containers this quarter that are amenable to this sort of loop. Syntax: for ( DATA_TYPE VARIABLE_NAME : CONTAINER ){ STATEMENT(S) } Example: #include <iostream>#include "console.h"using namespace std;int main(){ string s = "giraffe"; // Initially, ch is set equal to the first character in s. With each subsequent // iteration of the loop, ch moves forward by one character in the string. for (char ch : s) { cout << ch << endl; } return 0;} This produced the following output, where the string is tall and elongated, just like a giraffe. :) giraffe Conditional (If-Else) Statements and Comparison Operators The syntax for an if-statement in C++ is very similar to that of a while-loop. Note that the parentheses around the condition are required. Syntax: if ( CONDITION ){ STATEMENT(S) } In class, we started with a small example and continued to extend it until we reached the following: #include <iostream>#include "console.h"using namespace std;int main(){ int numCupcakes = 5; if (numCupcakes == 1) { cout << "Oh no! Running low!" << endl; } else if (numCupcakes > 1) { cout << "Hooray, cupcakes!" << endl; } else { cout << "Oh nooOoOoOOoo!" << endl; } return 0;} The comparison operators in C++ are: operator meaning < less than <= less than or equal to > greater than >= greater than or equal to == equal to != not equal to Note that the <= operator cannot be written as =< (with the equal sign up front). The same holds for the >= operator. One way to remember this (mnemonic time!) is that it's far more common to say "less than or equal to" in English than "equal to or less than." The order of the operators in C++ follows the conventional order of the adjectival phrases in English. Playing with each of these is left as an exercise. Boolean Operators At the very end of class today, we briefly examined the following three Boolean operators. operator meaning ! Boolean "not" && Boolean "and" || Boolean "or" The ! operator (the "not" operator) inverts a boolean value; true becomes false, and false becomes true. Accordingly, the following chunk of code: if (numCupcakes != 13){ cout << "Not a baker's dozen." << endl;} ... is semantically equivalent to: if (!(numCupcakes == 13)){ cout << "Not a baker's dozen." << endl;} Notice that when applying the ! operator to a whole expression (rather than a single variable), we use parentheses to wrap up the entire expression we wish to negate. The && operator (the "and" operator) evaluates to true if, and only if, both of its operands are true. For example: #include <iostream>#include "console.h"using namespace std;int main(){ int numCupcakes = 13; bool stillMakingPoorLifeChoices = true; if (numCupcakes == 13 && stillMakingPoorLifeChoices) { cout << "Hooray, cupcakes!" << endl; } return 0;} The || operator (the "or" operator) is true if at least one of its operands is true. For example: #include <iostream>#include "console.h"using namespace std;int main(){ int numCupcakes = 13; if (numCupcakes == 1 || numCupcakes == 2) { cout << "Uh oh! We're running low on cupcakes!" << endl; } return 0;} (Important Note!) You must use two ampersands for the && operator and two pipes for the || operator. If you just use a single & or |, you actually get a different operation. (The & and | operators are actually bitwise operators, which are discussed in CS107.) Catch-up Topic Common Pitfall with the || Operator In the following example, the cout statement is executed because C++ considers the value 2 to be true. If we want to check whether a variable is equal to one value or another, we need to apply the == operator twice. #include <iostream>#include "console.h"using namespace std;int main(){ int numCupcakes = 5; if (numCupcakes == 1 || 2) // Yikes! This evaluates to true! { cout << "Uh oh! We're running low on cupcakes!" << endl; } return 0;} Here's the correct version: #include <iostream>#include "console.h"using namespace std;int main(){ int numCupcakes = 5; if (numCupcakes == 1 || numCupcakes == 2) // Fixed! { cout << "Uh oh! We're running low on cupcakes!" << endl; } return 0;} Catch-up Topic Void Functions In this section, we define a few functions other than main() and explore return types, return values, and parameters. If a function takes no parameters, we simply leave the parameter list within its parentheses blank. If we write a function that does some work for us, but which we never expect to produce a meaningful value at the end of its execution, then it needn't return a value at all. In this case, we give the function a return type of void, like so: #include <iostream>#include "console.h"using namespace std;void greet(){ cout << "hello :)" << endl;}int main(){ greet(); return 0;} A void function does not require a return statement. We return to the function that called it when we reach the end of the function's definition. (Not covered in lecture.) Optionally, if we wish to leave a void function before its final line, we can simply return (without specifying a return value), like so: #include <iostream>#include "console.h"using namespace std;void processCupcakes(int numCupcakes){ if (numCupcakes < 0) { cout << "Invalid number of cupcakes." << endl; return; } // One can imagine doing something useful with numCupcakes here. // If we pass a negative value to this function, the following line // will not print. cout << "We reached the last line of the function." << endl;}int main(){ processCupcakes(-3); return 0;} Catch-up Topic Passing Parameters and Returning Values from Functions The following square() function is designed to take a single integer parameter, x, and return x2. To set this function up to accept a parameter, we give a full declaration for that variable within the parentheses in the function signature (the line with the function's name, return type, and parameter list). #include <iostream>#include "console.h"using namespace std;// We pass an integer to this function, and it returns an integer.int square(int x){ return x * x;}int main(){ square(5); return 0;} However, when we run the above program, nothing gets printed to the screen. That's because we never did anything in main() with the return value of our call to square(5). We must capture that return value. Here are two ways to print the return value to the screen: #include <iostream>#include "console.h"using namespace std;// We pass an integer to this function, and it returns an integer.int square(int x){ return x * x;}int main(){ // Option 1: Send the return value of square(5) directly to cout. cout << square(5) << endl; // Option 2: Store the return value in a variable and print that. int result = square(5); cout << result << endl; return 0;} The program now produces the following output: 2525 (Not covered in lecture.) If we want our function to print the result directly, we could write it as follows. Notice that the modified behavior of this function is reflected both in its modified name and the void return type: #include <iostream>#include "console.h"using namespace std;void printSquare(int x){ cout << x * x << endl;}int main(){ printSquare(5); return 0;} Catch-up Topic Function Placement and Functional Prototypes I mentioned toward the beginning of class that the C++ compiler processes your code line-by-line, starting at the very first line. A consequence of that is that if the compiler encounters a function call for a function that hasn't been defined yet (or for which we have not yet written the requisite #include statement), it goes kaput. For example: #include <iostream>#include "console.h"using namespace std;int main(){ cout << square(5) << endl; // ERROR: square() function not yet defined. return 0;}int square(int x){ return x * x;} What's happening above is that when we hit the cout line, C++ goes, "What's this square() function? Never heard of it." And it stops trying to compile the program in protest. There are two ways around this: Move the definition of the square() function above main(). Introduce a functional prototype! A functional prototype is just a function signature with a semicolon. A function signature is that first line of your function's definition that gives the return type, function name, and parameter list. Here's a functional prototype in action: #include <iostream>#include "console.h"using namespace std;// functional prototypeint square(int x);int main(){ cout << square(5) << endl; // This is okay now. return 0;}int square(int x){ return x * x;} This time, when C++ reaches the cout line, even though it doesn't have a definition for the square() function, it has a good idea (from having already seen the functional prototype) of how that function should be called, including the number and type of arguments it takes and its return type. It checks out the cout line and says, "Alrighty. I don't know how the square() function works yet, but I do know that the way you're calling it here fits with how I expect it to be called. Good work." It then carries on and successfully compiles the program. (Not covered in class.) Note that if we never defined the square() function, the program would not compile, even if we had a functional prototype. The compiler would fail at the very end of the file, when it realized there was no more code to process and it never got a definition for square(): #include <iostream>#include "console.h"using namespace std;// functional prototypeint square(int x);int main(){ cout << square(5) << endl; return 0;}// ERROR: Reached end of code without ever defining square() function. Catch-up Topic Variable Scope Variables only exist within the code blocks where they are declared -- or, in the event that you declare a variable in the header of a for-loop, that variable only exists within the loop. We refer to the regions of code that can refer to a particular variable as the variable's scope. For example: #include <iostream>#include "console.h"using namespace std;int main(){ for (int i = 0; i < 5; i++) { int q = 5; cout << i << endl; } cout << "i is: " << i << endl; // ERROR: undeclared variable cout << "q is: " << q << endl; // ERROR: undeclared variable return 0;} In the code above, we say that the i and q variables only exist within the scope of the for-loop. To refer to them outside the for-loop, they would have to be declared elsewhere. For example: #include <iostream>#include "console.h"using namespace std;int main(){ int i; int q; for (i = 0; i < 5; i++) { q = 5; cout << i << endl; } cout << "i is: " << i << endl; // OKAY cout << "q is: " << q << endl; // OKAY return 0;} What's next? On Friday, we continue our fast-paced introduction to C++! We'll talk about the "catch-up" topics indicated above, as well as pass-by-value functions, pass-by-reference, strings in C++, and some things related to testing our code. Exam Prep 1. After reviewing the notes, be sure to spend some time coding up your own examples from scratch. Play with the various operators and data types we saw in class today, and be sure to write loops and conditional statements to solidify your understanding of the syntax for those things in C++. 2. Be sure to glance through the notes labeled "(Not covered in class.)" to enrich and/or solidify your understanding of some of the finer points of this material. Those extra nuggets of information might prove useful at some point this quarter. 3. Be sure to glance through the notes labeled Catch-up Topic. Those give a sneak preview of the first few topics we will cover in our next lecture.
https://cs106b.stanford.edu/julieadvice
Philosophy First, a quote from Will Shortz, the crossword puzzle editor of the New York Times: A crossword puzzle is a battle between the puzzle maker and editor on one side and the solver on the other. But unlike most battles, both sides here have the same goal - for the solver to win. A perfect puzzle may put up lots of resistance. It may, in fact, seem impossible at first. Ideally, though, in the end the solver should triumph and think, Oh, how clever I am! - Will Shortz, How to solve I love the spirit of this quote as it applies to exams. We absolutely want you to come out on top! The lectures, sections, and assignments work together to guide you toward mastery of the course learning goals and the exams serve as an assessment of your progress. The absolute best outcome everyone has a great grasp on the material to nail the exam. Read on for more advice on how to make that happen for you! What to expect Our exams are designed to evaluate your mastery of the course learning goals. We will focus on material from the assignments, section, lecture, and reading (this list is in order of decreasing emphasis). Having spent two solid weeks on recursion in all its glory, you can count on the exam asking you to demonstrate recursive problem solving. On the other hand, we would never test you on an obscure fact that only had the briefest of mentions buried in the textbook. Answering the exam questions is typically going to require good comprehension of the foundational concepts and the ability to analyze and apply them in a given situation. We are evaluating that not only did you successfully complete the assignments and sections, but that you came away with a comprehension you can demonstrate. We will not ask superficial questions about terminology (e.g. "Define hashing") or details that can/should be looked up on demand ("Which header file has this prototype?"). Many questions will ask you to write C++ code. Other questions may ask you to analyze C++ code: to trace its behavior, to analyze its Big O runtime, to identify and fix flaws, or draw a picture of the memory layout. There may also be short-answer thought questions about various algorithmic techniques (searching, sorting, hashing), tradeoffs in data structure design, and the like. When scoring answers, we will not be picky about minor syntax and oversights (missing braces around a block of clearly indented code, we don't ask for #include's etc.). The lion's share of the points are reserved for demonstrating a correct conceptual understanding and a valid approach to solving the problem, with somewhat fewer points for the minute details of executing on your plan. In our view, a solid first-pass approximation that shows the correct conceptual understanding of the key issues deserves to be strongly distinguished from code that exhibits significant conceptual issues and would require much trial-and-error with compiler/debugger to turn into working code. Why no IDE? The intent of our assessments is to evaluate your ability to think logically and apply problem-solving skills to reading and writing code. If you were facing an actual compiler, there would also be a multitude of syntax hurdles, typos, and mundane build issues you would have to overcome to turn the code into reality. In your assignments, you have already shown us many times over that you can work through these issues, and we do not wish to further assess these skills. Bear in mind that your answers will be scored by our very capable human section leaders, not inflexible compilers! We look beyond the nit-picky details to evaluate the heart of your problem-solving approach and its correctness. Here are more of our thoughts on the advantages of coding without an IDE. Before the exam: prep for success The long view. The mastery for the exams isn't created by a night of cramming, it is built up throughout the quarter. Make it a priority to monitor your own progress and identify holes or confusion to be shored up before moving on. The only exam-specific preparation is that you practice under exam-like conditions (i.e. without IDE, on paper, timed). Invest in your summary/notesheet. The exam is closed-book. We provide a reference sheet and you may bring in your own prepared notesheet. Creating your notesheet is itself a great way to study for the exam. Reviewing the topics and determining what information is worth including on your notesheet will remind you of where we've been and help you take stock of your comfort level with the course topics. Use this opportunity to identify any areas on which you feel weak and resolve dangling issues before heading into the exam. Recreate the environment. It is not a given that your real-world skills will translate to the exam setting without first becoming familiar with how the experience is different. The best practice is to solve problems without aid of compiler/debugger, in longhand using pencil and paper under a time limit, just as you will have to during the exam. Practice makes perfect. Take problems (lecture or section example, textbook exercise, sample exam problem) and write out a solution under exam-like conditions. Review it to see how you did. This is much more valuable than a passive review of the problem and its solution where it is too easy to conclude "ah yes, I would have done that" only to find yourself adrift during the real exam when there is no provided solution to guide you! Get your questions answered. If there is a concept you're a bit fuzzy on, or you'd like to check your answer to an exercise, or you wonder why a solution is written a particular way, get those questions answered before the exam. Swing by the lair, come to office hours, or post on the forum and we're happy to help. During the exam: in the heat of battle Scan the entire exam first. Quickly peruse all questions before starting on any one. This allows you to "multi-task"- as you are writing the more mundane parts of one answer, your mind can be brainstorming strategies or ideas for another problem in the background. You can also sketch out how to allocate your time between questions in the first pass. Spend your time wisely. There are only a handful of questions, and each is worth a significant amount. Don't get stuck on any particular problem. There is much opportunity for partial credit, so it's better to make good efforts on all problems than to perfect an answer to one leaving others untouched. Consider the point value of each question. Divide the total minutes by the total number of points to figure the time per point and use that as guide when allocating your time across the problems. Pay attention to specific instructions. A problem statement may include detailed constraints and hints such as "you must solve this recursively" or "you should not destructively modify the input list" or "you do not have to handle the case when the string is empty" or "this operation must run in constant time". You may want to underline or highlight these instructions to be sure you don't overlook them. These constraints are not intended to make things difficult, typically we are trying to guide you in the direction of a straightforward and simple solution. If you disregard these instructions, you are likely to lose points, either for not meeting the problem specification and/or for errors introduced when attempting a convoluted alternative. Ask a question rather than answer the wrong one. If you are uncertain about what a question is asking or find some part of the question ambiguous, it's worth your time to ask the course staff for a clarification so you can be sure you are solving the right problem before you start working on it. Syntax is not that important if it is clear what you mean. We won't trouble you about most syntax as long as your intentions are clear. But if there is ambiguity in your attempt, correct syntax can help us get the correct meaning. For example, if we see a for statement followed by two lines, where both lines are vaguely indented or a third line has been added in after the fact, we may be confused. If there are braces around all the lines, it will be clear you intended both to be a part of the loop body, but without the braces, we can't be sure and it may make your answer incorrect. Style and decomposition are secondary to correctness. Unlike the assignments where we hold you to high standards in all areas, for an exam, the correctness of the answers that dominates the grading. Decomposition and style are thus somewhat de-emphasized. However, good design may make it easier for you to get the functionality correct and require less code, which takes less time and has fewer opportunities for error. Comments are never required unless specifically indicated by a problem. When a solution is incorrect, commenting may help us determine what you were trying to do and award partial credit. Answer in pseudocode only if you must. If the syntax of C++ is blocking you from writing a solution, you can answer in pseudocode for possible partial credit. We discourage this approach as pseudocode is often lacking in detail or just restates the problem description ("I would recursively try all the subsequences to find the longest"). Such answers will earn little, if any, credit. Sufficiently detailed pseudocode (e.g. "scan the next token from input, if it the first char is a digit, then convert to an integer") would have been easier and more concise to write in C++ and will earn more points that way. Save a little time for checking your work. Reserve a few minutes to go back over your work. We try not to deduct points for minor things if it is obvious what you meant, but sometimes it is difficult to decipher your true intention. You might save yourself a few lost points by tidying up the details at the end. Final Thoughts Always remember why you are here! Your efforts to build practice skills and real understanding will take you a lot further than a pristine transcript. If you work hard toward mastery and feel good about your understanding of computer science that is an achievement you can be proud of!
https://cs106b.stanford.edu/lair
What are LaIR helper hours? LaIR helper hours are the in-person office hours for the CS106 courses. The LaIR is staffed by our awesome team of CS198 section leaders. Students come to the LaIR to get individual help with debugging assignments and answers to their conceptual questions. There is also additional LaIR-style support offered by some student-run organizations: Black LaIR, run by Stanford Black in CS WICS LaIR, run by Stanford Women in Computer Science LaIR Schedule LaIR is open Sunday through Thursday, 7 - 11 PM Pacific Time. LaIR starts the second week of the quarter. In-person LaIR queue LaIR is held in Durand 353 (glass conference room across from 3rd floor elevator). All CS106 students are authorized for after-hours entry to Durand (use your Stanford ID card at the card reader outside the front door). To request help, come to Durand and add your request to the Lair queue The request queue is managed online. Add your request on the LaIR signup page. Be sure to properly identify your location when signing up so the helper can find you when your turn comes up. All requests are handled in first-come-first-served order. Remote access to the LaIR virtual queue Remote access to LaIR is provided to SCPD students, students with OAE accommodations that require remote access, and students who are in COVID isolation. Non-SCPD students who need remote access must first make arrangements by emailing the Head TA. SCPD students automatically receive access to Remote LaIR for the entire quarter; no need to send email. For those with OAE accommodations, please email the Head TA your OAE letter specifying need for remote access. Indicate clearly in your email the start and end dates you will require remote access (you may write "entire quarter" if that is the case). If you test positive or receive an exposure notification, please email the Head TA with a screenshot of your positive test (with name and date visible) or exposure notification (with name and date visible). Indicate clearly in your email the start and end dates of isolation. Temporary access is removed after your end date has passed. Signing into the Lair queue as a remote user is a similar process to in-person signup. Use the standard LaIR signup page and when adding your request to the queue, put your Zoom link in the location field. When your turn comes up, the helper will connect to your Zoom link. Students must not falsify documentation for remote access, attempt to bypass checks to access lair remotely, or share links or logins with other students for remote access. Such actions are in violation of the Fundamental Standard and will be referred to the Office of Community Standards. Common questions about LaIR I tried to sign up for LaIR, but the queue was closed, even though the schedule says LaIR is open now. What gives? In times of high demand, we may need to close the queue to new requests toward the end of the shift. We do this to ensure that we have sufficient resources to assist all students already in the queue.
https://cs106b.stanford.edu/assignments/2-adt/maze.html
A maze is a twisty arrangement of corridors that challenges the solver to find a path from the entry to the exit. This part of the assignment is about using ADTs to represent, process, and solve mazes. An introduction to mazes Labyrinths and mazes have fascinated humans since ancient times (remember Theseus and the Minotaur?), but mazes can be more than just recreation. The mathematician Leonhard Euler was one of the first to analyze mazes mathematically, and in doing so, he founded the branch of mathematics known as topology. Many algorithms that operate on mazes are closely related to graph theory and have applications to diverse tasks such as designing circuit boards, routing network traffic, motion planning, and social networking. Your goal for the maze portion of the assignment to implement neat algorithms to solve a maze, while gaining practice with ADTs. Before jumping into the code, please carefully read this background information on how we will represent mazes, which ADTs to use, and the format of the provided maze data files. A Grid represents a maze A maze can be modeled as a two-dimensional array where each element is either a wall or a corridor. The Grid from the Stanford library is an ideal data structure for this. A maze is represented as a Grid<bool>. Each grid element is one "cell" of the maze. The element at location (row, col) is true when there is an open corridor at that location and false if it is a wall. A maze is read from a text file. Each line of the file is one row of the maze. Within a row, the character @ is a wall, and - is a corridor. Here is a sample 5x7 maze file (5 rows by 7 columns): ------- -@@@@@- -----@- -@@@-@- -@---@- A GridLocation is a struct containing fields row and col The GridLocation is a companion type to represent a location in a Grid. A GridLocation has two fields, row and col, that are packaged together a C++ struct. The sample code below demonstrates using a GridLocation variable and assigning and accessing its row and col fields. // Declare a new GridLocation GridLocation chosen; // GridLocation provides default initialization to 0,0 chosen.row = 3; // assign row of chosen location to 3 chosen.col = 4; // assign col of chosen location to 4 // Alternative way to initialize row,col when declaring a GridLocation GridLocation exit = { maze.numRows()-1, maze.numCols()-1 }; // Can use a GridLocation to index into a Grid // Below test checks whether chosen location is an open corridor if (maze[chosen]) // chosen was set to {3, 4} so this accesses maze[3][4] ... // Can compare two GridLocations for equality if (chosen == exit) ... // Can access the GridLocation's row & col fields by name using dot syntax if (chosen.row == 0 && chosen.col != 0) ... A Vector of GridLocations is a path A path through the maze is an ordered sequence of connecting GridLocations. Using a Vector<GridLocation> is just right! A valid maze solution path starts at the maze entrance, steps through connecting GridLocations, and ends at the maze exit. In the "Other files/res" folder, a .soln text file contains a solution for the corresponding maze files. Here is the solution file for the 5x7 maze shown earlier. The solution path is a sequence of 11 GridLocations, starting at r0c0 (row 0, col 0), and ending at r4c6. {r0c0, r0c1, r0c2, r0c3, r0c4, r0c5, r0c6, r1c6, r2c6, r3c6, r4c6} Our starter code provides the function readSolutionFile that reads a solution path into a Vector<GridLocation>. Not every provided maze has a corresponding .soln file, part of your job will be to write code to generate solutions! Resources for the Stanford ADTs Documentation for Stanford collections: Grid, GridLocation, Stack, Queue, Vector Section 6.1 of the textbook introduces struct types In the lower-left corner of your Qt Creator window, there is a magnifying glass by a search field. If you type the name of a header file such as grid.h or gridlocation.h , Qt will display the corresponding header file. A few reminders for using our ADT/templates: The assignment operator for our ADTs makes a deep copy. Assigning from one Vector/Set/Stack to another creates a copy of the ADT and a copy of all its elements. When using a C++ template, the type name must include the type of element being stored. Declaring a Vector without specifying the element type just won't fly, and a Vector<int> is not the same thing as a Vector<string>. The error messages you receive when you have mismatches in template types can be cryptic and hard to interpret. Bring your template woes to LaIR or the Ed forum, and we can help untangle them with you. On to the code! In maze.cpp, you will write two helper functions that process grids and paths and two maze-solving functions. You will also be writing comprehensive test cases. 1) Write helper function generateValidMoves() Your first task is to implement the helper function to generate the neighbors for a given location: Set<GridLocation> generateValidMoves(Grid<bool>& maze, GridLocation cur) Given a maze represented as a Grid of bool and a current GridLocation cur, this function returns a Set of all valid moves from cur. Valid moves are those GridLocations that are: Exactly one "step" away from cur in one of the four cardinal directions (N, S, E, W) Within bounds for the Grid (hint: Grid has a handy inBounds check) An open corridor, not a wall There are a few provided tests for generateValidMoves, but these tests are not fully comprehensive. Write at least 3 additional tests to make sure your helper function works correctly. Remember to label your tests as STUDENT_TEST. 2) Write helper function validatePath() Next you'll write a function to confirm that a path is a valid maze solution: void validatePath(Grid<bool>& maze, Vector<GridLocation>& path) The image above displays a valid solution; each colored dot marks a GridLocation along the path. A path is a valid solution to a maze if it meets the following criteria: The path is not empty The path starts at the entry (upper left corner) of the maze The path ends at the exit (lower right corner) of the maze Each location in the path is a valid move from the previous path location Hint: rather than re-implement the same logic you already did for generateValidMoves, simply call that function and check whether a move is contained in the set of valid moves. The path must not contain a loop, i.e. the same location cannot appear more than once in the path Hint: a Set<GridLocation> is a good data structure for tracking seen locations and avoiding a repeat. The function validatePath completes successfully if all of the criteria for a valid solution are met. If it instead detects that the path violates one of the above constraints, validatePath should call the error function from error.h to report what is wrong. The error function stops execution and prints your explanatory message: error("Here is my message about what has gone wrong"); The function validatePath will require careful testing to confirm that it correctly detects all forms of valid and invalid paths. We've provided a few tests to get you started, but you will need additional tests of your own to complete the job. Write at least 3 student test cases for validatePath. Note the use of the new test types EXPECT_ERROR and EXPECT_NO_ERROR in our provided tests. An EXPECT_ERROR test case evaluates an expression, expecting that the operation will raise an error. While executing the test, the SimpleTest framework will "catch" the error, record that it happened, and resume. Because the error was expected, the test case is marked Correct. If an error was expected but didn't materialize, the test case is marked Incorrect. EXPECT_NO_ERROR operates in the reverse: it expects the code to run without errors and if so, it is Correct. If an error is raised, it is marked Incorrect. More information on the different test macros can be found in the CS106B Testing Guide. After writing validatePath, not only will you be familiar with using the ADTs to represent mazes, now you have a function to help when testing the functions you will write next. Having thoroughly tested your validatePath on a variety of invalid paths means you can be confident that it is the oracle of truth when it comes to confirming a solution. Your future self thanks you! Q5. After you have written your test cases, describe your testing strategy to confirm that your validatePath operates as intended. How confident are you that it works correctly in all cases? Notes about our provided maze files The starter project includes a res folder containing maze files of various sizes, some with solutions. The maze.cpp file includes code for the functions readMazeFile and readSolutionFile. We provide these files and code to help with your testing. Please use them! You can also create additional mazes of your own. All maze files are well-formed and can be successfully read by readMazeFile. The maze grid is rectangular and contains at least two rows and two columns. The grid locations at upper-left (entrance) and lower-right (exit) are both open corridors. All solution files are well-formed and can be successfully read by readSolution File. if a maze has a corresponding solution file, the solution file contains a path that is a valid solution for the maze. If a maze does not have a solution file, it may or may not be solvable. 3) Write solveMazeBFS() Now you're ready to tackle the solve function that finds a solution path for a given maze. bool solveMazeBFS(Grid<bool>& maze, Vector<GridLocation>& soln) Solving a maze can be seen as a specific instance of a path-finding problem, where the challenge is to find a route from the entrance to the exit. Path-finding comes up in a variety of situations such as packet routing on the internet, robot motion planning, analyzing gene mutations, spell correction, and more. Breadth-first search (BFS) is a classic and elegant algorithm for finding a path. A breadth-first search considers paths outward from the entry location in a radial fashion until it finds the exit. The first paths examined take one hop from the entry. If any of these reach the exit location, success! If not, the search expands to those paths that are two hops long. At each subsequent step, the search expands radially, examining all paths of length three, then of length four, and so on, stopping at the first path that reaches the exit. Breadth-first search is typically implemented using a queue. The queue stores partial paths that represent possibilities to explore. The first paths enqueued are all length one, followed by enqueuing the length two paths, and so on. Because a queue processing elements in FIFO order, all shorter paths are dequeued and processed before the longer paths make their way to the front of queue. This means paths are tried in order of increasing length and thus a solution path found via breadth-first search will be the shortest possible such solution. At each step, the algorithm considers the current path at the front of the queue. If the current path ends at the exit, it must be a completed solution path. If not, the algorithm considers the current path, extends it to reach locations that are one hop further away in the maze, and enqueues those extended paths to be examined in later rounds. Here are the steps followed by a breadth-first search: Create an empty queue of paths. Each path is a Vector<GridLocation> and the queue of paths is of type Queue<Vector<GridLocation>>. A nested ADT type like this looks a little scary at first, but it is just the right tool for this job! Create a length-one path containing just the entry location. Enqueue that path. In our mazes, the entry is always the location in the upper-left corner, and the exit is the lower-right. While there are still more paths to explore: Dequeue the frontmost element from the queue. This is the current path. If the current path ends at exit: You're done, the current path is a solution! Otherwise: Determine the viable neighbors from the end location of the current path. A viable neighbor is a valid move that has not yet been visited during the search. For each viable neighbor, make copy of current path, extend by adding neighbor and enqueue it. Repeat step 3. If the queue of paths is empty, this maze has no solution. Some details to keep in mind as you're implementing BFS: The search should not revisit previously visited locations or create a path with a cycle. For example, if the current path leads from location r0c0 to r1c0, you should not extend the path by moving back to location r0c0. You should not call validatePath within your solveMazeBFS function, but you can call it in your test cases to confirm the validity of paths found by solveMazeBFS. If a solution was found, the function returns true and the pass-by-reference parameter soln stores the solution. If the maze could not be solved, the function returns false. For a helpful visualization and debugging aid, you can use our provided mazegraphics to add a graphical animation of the algorithm. We have provided some tests to get your started. Add 2 or more student tests that further verify the correct functionality of the solveMazeBFS function. 4) Write solveMazeDFS() Your final task for maze is to implement depth-first search: bool solveMazeDFS(Grid<bool>& maze, Vector<GridLocation>& soln) Depth-first search is an alternate path-finding algorithm that works similarly to breadth-first search, but tries the possible paths in a different order. Once a depth-first search starts on a path, it goes deep, continuing until it reaches its ultimate end and only if unsuccessful, moves on to try other paths. Both algorithms consider all possible paths in search of a solution, the difference being in which order they consider the paths. The power of ADTs makes it magically easy to convert between the two algorithms. Depth-first search uses the same steps for a breadth-first search but everywhere you see queue with enqueue/dequeue operations, substitute a stack with push/pop operations. Whereas BFS uses a queue of paths, enqueuing paths to the back and dequeuing the next path to explore from the front, a DFS instead uses a stack and pushes paths to the top and popping the next path to explore from the top. Using a queue considers paths in FIFO (first-in-first-out) order , a stack will process the paths in LIFO (last-in-first-out) order. This means that implementing solveMazeDFS is going to be a snap - just a switcheroo in which ADTs are being used. For this function: copy/paste your working implementation from solveMazeBFS change the data type of allPaths from Queue<Vector<GridLocation>> to Stack<Vector<GridLocation>> change Queue operations (enqueue/dequeue) into Stack operations (push/pop) Voila, you've done it! Add tests to confirm the solutions found by solveMazeDFS are valid according to validatePath. You now have two powerful algorithms to solve a maze and have gotten lots of practice with ADTs - way to go! Congratulations! Q6. Most students are sold on the benefit of the fancy features provided by Vector, Grid, and Set but the ADT skeptics may question the value of Stack and Queue ADTs, seeing them as nothing more than a restricted Vector. Make your best argument to convince them of the benefits these ADTS have over Vector. Graphics (optional) As BFS or DFS is exploring various paths through the maze, you may be wishing you could follow along to ensure your algorithm is working as you intend. One good option is running under the debugger as you did in the warmup, watching how the variables change as you step through the code. We also thought an animation that shows the progress of the algorithm visually could be neat, so we wrote some graphic support routines that you can try out. This is entirely optional, but using them may help with your debugging and testing and just generally make the program more fun. The provided mazegraphics module has functions to initialize the graphics for a maze and highlight the current path. Read the mazegraphics.h header file for more details about: initGraphicsForMaze(Grid<bool>& maze, bool pauseForClick) highlightPath(Vector<GridLocation>& path, string color) The general idea is to call initGraphicsForMaze once before starting the search. Each time you dequeue/pop a new current path, call highlightPath to display it. If you supply true as the second argument to initGraphicsForMaze, each call to highlightPath will pause and wait for the user to click before continuing. This gives you time to watch the animation and see how the path is updated and follow along with the algorithm and debug its operation. There is no requirement that your solver animate its process, our testing will only confirm that you correctly find solution paths. If you don't think the animation will be valuable or you find it that it introduces more problems than it solves, you are free to skip it. References There are many interesting facets to mazes and much fascinating mathematics underlying them. Mazes will come up again several times this quarter. Chapter 9 of the textbook uses a recursive depth-first search as path-finding algorithm. At the end of the quarter when we talk about graphs, we'll explore the equivalence between mazes and graphs and note how many interesting results in mazes came from breakthroughs in graph algorithms. Walter Pullen, Maze Classification. http://www.astrolog.org/labyrnth/algrithm.htm Website with lots of great info on mazes and maze algorithms Jamis Buck. Maze Algorithms. https://www.jamisbuck.org/mazes/ Fun animations of maze algorithms. He also wrote the excellent book about Mazes for Programmers: Code Your Own Twisty Little Passages. Extensions If you have completed the assignment and want to explore further, here are some ideas for extensions. Instead of reading pre-written mazes from a file, you could instead generate a new random maze on demand. There are an amazing (I could not resist...) variety of algorithms for maze construction, ranging from the simple to the sublime. Here are a few names to get you started: backtracking, depth-first, growing tree, sidewinder, along with algorithms named for their inventor: Aldous-Broder, Eller, Prim, Kruskal, Wilson, and many others. Try out other maze solving algorithms. How does BFS and DFS measure up against the approaches in terms of solving power or runtime efficiency? Take a look at other solvers such as random mouse, wall following, recursive depth-first, Bellman-Ford, or others. There are many other neat maze-based games out there that make fun extensions. You might gather ideas from Robert Abbott's http://www.logicmazes.com or design a maze game board after inspiration from these musings on mazes from Chris Smith. The last word from XKCD https://xkcd.com/2407/
https://cs106b.stanford.edu/assignments/1-cpp/perfect.html
This warmup task gives you practice with C++ expressions, control structures, and functions, as well as testing and debugging your code. Throughout the writeup, we pose thought questions (in the highlighted yellow boxes) for you to answer. The starter project includes the file short_answer.txt (located under "Other Files" in the Qt Project pane). Edit this file to fill in your responses and submit it with your code. Your section leader will review your responses as part of grading. We'll be evaluating the sincerity and thoughtfulness of your reflection and reasoning; not a rigid "right/wrong" thing. Perfect numbers This exercise explores a type of numbers called perfect numbers. Before we jump into the coding, let's begin with a little math and history. A perfect number is an integer that is equal to the sum of its proper divisors. A number's proper divisors are those positive numbers that evenly divide it, excluding itself. The first perfect number is 6 because its proper divisors are 1, 2, and 3, and 1 + 2 + 3 = 6. The next perfect number is 28, which equals the sum of its proper divisors: 1 + 2 + 4 + 7 + 14. Perfect numbers are an interesting case study at the intersection of mathematics, number theory, and history. The rich history of perfect numbers is a testament to how much these numbers have fascinated humankind through the ages. Using our coding powers, we can explore different algorithmic approaches to finding these special numbers. An exhaustive algorithm One approach to finding perfect numbers is using an exhaustive search. This search operates by brute force, looping through the numbers one by one, and testing each to determine if it is perfect. Testing whether a particular number is perfect involves another loop to find those numbers which divide the value and add those divisors to a running sum. If that sum and the original number are equal, then you've found a perfect number! Here is some Python code that performs an exhaustive search for perfect numbers: def divisor_sum(n): total = 0 for divisor in range(1, n): if n % divisor == 0: total += divisor return total def is_perfect(n): return n != 0 and n == divisor_sum(n) def find_perfects(stop): for num in range(1, stop): if is_perfect(num): print("Found perfect number: ", num) if num % 10000 == 0: print('.', end='',flush=True) # progress bar print("Done searching up to ", stop) The Python code from above is re-expressed in C++ below. If your CS106A was taught in Python, comparing and contrasting these two may be a helpful way to start adapting to the language differences. If instead your prior experience was in Java or Javascript, just sit back and enjoy how C++ already seems familiar to what you know! /* The divisorSum function takes one argument `n` and calculates the * sum of proper divisors of `n` excluding itself. To find divisors * a loop iterates over all numbers from 1 to n-1, testing for a * zero remainder from the division using the modulus operator % * * Note: the C++ long type is a variant of int that allows for a * larger range of values. For all intents and purposes, you can * treat it like you would an int. */ long divisorSum(long n) { long total = 0; for (long divisor = 1; divisor < n; divisor++) { if (n % divisor == 0) { total += divisor; } } return total; } /* The isPerfect function takes one argument `n` and returns a boolean * (true/false) value indicating whether or not `n` is perfect. * A perfect number is a non-zero positive number whose sum * of its proper divisors is equal to itself. */ bool isPerfect(long n) { return (n != 0) && (n == divisorSum(n)); } /* The findPerfects function takes one argument `stop` and performs * an exhaustive search for perfect numbers over the range 1 to `stop`. * Each perfect number found is printed to the console. */ void findPerfects(long stop) { for (long num = 1; num < stop; num++) { if (isPerfect(num)) { cout << "Found perfect number: " << num << endl; } if (num % 10000 == 0) cout << "." << flush; // progress bar } cout << endl << "Done searching up to " << stop << endl; } Observing the runtime The starter project contains the C++ code above. It is given to you pre-written and works correctly. Look over the code and confirm your understanding of how it works. If you have questions or points of confusion, make a post on Ed to start a conversation or come by Lair or office hours. We want you to first observe the performance of the given code. One simple approach for measuring runtime is to simply run the program while keeping an eye on your watch or a clock. Open the starter project in Qt Creator and build and run the program. When you are prompted in the console to "Select the test groups you wish to run," enter 0 for "None" and the program will instead proceed with the ordinary main function. This main function does a search for perfect numbers across the range 1 to 40000. Watch the clock while the program runs and note the total elapsed time. Q1. Roughly how long did it take your computer to do the search? How many perfect numbers were found and what were they? You now have one timing result (how long it takes for a range of size 40000), but would need additional data to suss out the overall pattern. What would be ideal is to run the search several times with different search sizes (20000, 40000, 80000, etc.) and measure the runtime for each. To do this manually, you would edit main.cpp, change the argument to findPerfects and re-run the program while again watching the clock. Repeating for many different sizes would be tedious. It would be more convenient to run several time trials in sequence and have the program itself measure the elapsed time. The SimpleTest framework can help with this task, so let's take a detour there now. What is SimpleTest? In CS106B, you will use a unit-test framework called SimpleTest to test your code. This type of testing support will be familiar to you if you've been exposed to Java's JUnit or python doctest. (and no worries if you haven't yet, there will be much opportunity to practice with unit testing in CS106B!) Stop here and read our guide to testing to introduce yourself to SimpleTest. For now, focus on use of STUDENT_TEST, EXPECT, EXPECT_EQUAL, and TIME_OPERATION, as these are the features you will use in Assignment 1. Practice with TIME_OPERATION Now that you know the basics of SimpleTest, you are ready to practice with it using the provided tests in perfect.cpp. Open the perfect.cpp file and scroll to the bottom. Review the provided test cases to see how they are constructed. One of the provided test shows a sample use of TIME_OPERATION to measure the time spent during a call to findPerfects. Run the program and when prompted to "Enter your selection," enter the number that corresponds to the option for the perfect.cpp tests. This will run the test cases from the file perfect.cpp. The SimpleTest window will open to show the results of each test. The given code should pass all the provided tests. This shows you what a successful sweep will look like. Note that the SimpleTest results window also reports the elapsed time for each TIME_OPERATION. When constructing a time trial test, you will want to run several TIME_OPERATION across a set of different input sizes that allow the trend line to emerge. Selecting appropriate input sizes is a bit of an art form. If you choose a size that is too small, it can finish so quickly that the time is not measurable or gets lost in the noise of other activity. A size that is too large will have you impatiently waiting for it to complete. You are generally aiming for test cases that complete in 10-60 seconds. Note that a size that is just right for your friend's computer might be too small or too larger for yours, so you may need a bit of trial and error on your system to find a good range. Set up an experiment by adding a STUDENT_TEST that does a single TIME_OPERATION of findPerfects. Try different sizes to determine the largest size which your computer can complete in around 60 seconds or so. Now edit your STUDENT_TEST to do four time trials on increasing sizes, doubling the size each time and ending with the final trial of that large size. The starter code includes some sample code showing how to use a loop to configure a series of time trials. This is a great technique to add to your repertoire! Run your time trials and write down the reported times. Q2. Make a table of the timing results for findPerfects that you observed. (old-school table of text rows and columns is just fine) Use the data from your table to work out the relationship between the search size and the amount of time required. To visualize the trend, it may help to sketch a plot of the values (either by hand or using a tool like https://www.desmos.com/calculator). You will find that doubling the input size doesn't take simply twice the time; the time goes up by a factor of 4. There appears a quadratic relationship between size and program execution time! Let's investigate why this might be. Q3. Does it take the same amount of work to compute isPerfect on the number 10 as it does on the number 1000? Why or why not? Does it take the same amount of work for findPerfects to search the range of numbers from 1-1000 as it does to search the numbers from 1000-2000? Why or why not? That quadratic relationship means the algorithm is going to seriously bog down for larger ranges. Sure, the first four perfect numbers pop out in a jif (6, 28, 496, 8128) because they are encountered early in the search, but that fifth one is quite a ways off - in the neighborhood of 33 million. Working up to that number by exhaustive search is going to take l-o-o-ng time. Q4. Extrapolate from the data you gathered and make a prediction: how long will it take findPerfects to reach the fifth perfect number? This is your first exposure to algorithmic analysis, a topic we will explore in much greater detail throughout the course. As a fun aside, if you have access to a Python environment, you can attempt similarly-sized searches using the Python version of the program to see just how much slower an interpreted language (Python) is compared to a compiled language (C++). Check out the Python vs C++ Showdown we've posted to the Ed discussion forum. Digging deeper into testing Having completed these observations about performance, we move on to testing the code, which is one of the most important skills with which we hope you will come out of this class. Designing good tests and writing solid, well-tested code are skills that will serve you well for the rest of your computer science journey! Here are some further explorations to do with SimpleTest: All perfect numbers are positive, there is no such thing as a negative perfect number; thus isPerfect should return false for any negative numbers. Will you need to make a special case for this or does the code already handle it? Let's investigate... Look at the code and make a prediction about what happens if isPerfect is given a negative input. Add a new STUDENT_TEST case that calls isPerfect on a few different negative inputs. The expected result of isPerfect for such inputs should be false. A quick reminder that the tests that we give you in the starter code will always be labeled PROVIDED_TEST and you should never modify the provided tests. When you add tests of your own, be sure to label them STUDENT_TEST. This allows your grader to easily identify which tests are yours. We also prefer that your list your STUDENT_TEST cases first, ahead of the PROVIDED_TEST cases. Run your new test cases to confirm that the code behaves as expected. Introduce a bug into divisorSum by erroneously initializing total to 1 instead of zero. Rebuild and run the tests again. This lets you see how test failures are reported. Q5. Do any of the tests still pass even with this broken function? Why or why not? Be sure to undo the bug and restore divisorSum to a correct state before moving on! Streamlining and more testing The exhaustive search does a lot of work to find the perfect numbers. However, there is a neat little optimization that can significantly streamline the process. The function divisorSum runs a loop from 1 to N to find divisors, but this is a tad wasteful, as we actually only need to examine divisors up to the square root of N. Each time we find a divisor, we can directly compute what the corresponding pairwise factor for that divisor (no need to search all the way up to N to find it). In other words, we can take advantage of the fact that each divisor that is less than the square root is paired up with a divisor that is greater than the square root. Take a moment to carefully think about why this is true and how you would rearrange the code to capitalize on this observation. You are to implement a new function smarterSum: long smarterSum(long n) that produces the same result as the original divisorSum but uses this optimization to tighten up the loop. You may find it helpful to use the provided divisorSum implementation as a starting point (that is, you may choose to copy-paste the existing code and make tweaks to it). Be careful: there are some subtle edge cases that you may have to handle in the adapted version that were not an issue in the original. The C++ library function sqrt can be used to compute a square root. After adding new code to your program, your next step is to thoroughly test that code and confirm it is bug-free. Only then should you move on to the next task. Having just written smarterSum, now is the time for you to test it. Because you already have the vetted function divisorSum at your disposal, a clever testing strategy uses EXPECT_EQUAL to confirm that the result from divisorSum(n) is equal to the result from smarterSum(n). Rather than pick any old values for n, brainstorm about which values would be particularly good candidates. As an example, choosing n=25 (which has an square root that is an integer value) could confirm there is no off-by-one issue on the stopping condition of your new loop. Add at least 3 new student test cases for smarterSum. Q6. Explain your testing strategy for smarterSum and how you chose your specific test cases that lead you to be confident the function is working correctly. Now with confidence in smarterSum, implement the following two functions that build on it: bool isPerfectSmarter(long n) void findPerfectsSmarter(long stop) The code for these two functions is very similar to the provided isPerfect and findPerfects functions, basically just substituting smarterSum for divisorSum. Again, you may copy-paste the existing implementations, and make small tweaks as necessary. Now let's run time trials to see just how much improvement we've gained. Add a STUDENT_TEST that uses a sequence of TIME_OPERATION to measure findPerfectsSmarter. Set up 4 runs on increasing sizes, doubling the size each time, and ending with a run on the maximum size your program can complete in around 60 seconds using this improved algorithm. Given the smarter algorithm, these sizes will be larger than you used for the original version. Q7. Record your timing results for findPerfectsSmarter into a table. Our previous algorithm grew at the rate N^2, while this new version is since we only have to inspect divisors for every number along the way. If you plot runtimes on the same graph as before, you will see that they grow much less steeply than the runtimes of the original algorithm. Q8. Make a prediction: how long will findPerfectsSmarter take to reach the fifth perfect number? Mersenne primes and Euclid Back to story time: in 2018, there was a rare finding of a new Mersenne prime. A Mersenne number is a number that is one less than a power of two, i.e., of the form 2k-1 for some integer k. A prime number is one whose only divisors are 1 and the number itself. A Mersenne number that is prime is called a Mersenne prime. The Mersenne number 25-1 is 31 and 31 is prime, making it a Mersenne prime. Mersenne primes are quite elusive; the most recent one found is only the 51st known and has almost 25 million digits! Verifying that the found number was indeed prime required almost two weeks of non-stop computing. The quest to find further Mersenne primes is driven by the Great Internet Mersenne Prime Search (GIMPS), a cooperative, distributed effort that taps into the spare computing cycles of a vast community of volunteer machines. Mersenne primes are of great interest because they are some of the largest known prime numbers and because they show up in interesting ways in games like the Tower of Hanoi and the wheat and chessboard problem. Back in 400 BCE, Euclid discovered an intriguing one-to-one relationship between perfect numbers and the Mersenne primes. Specifically, if the Mersenne number 2k-1 is prime, then 2(k-1) * (2k-1) is a perfect number. The number 31 is a Mersenne prime where k = 5, so Euclid's relation applies and leads us to the number 24 * (25-1) = 496 which is a perfect number. Neat! Those of you enrolled in CS103 will appreciate this lovely proof of the Euclid-Euler theorem. Turbo-charging with Euclid The final task of the warmup is to leverage the cleverness of Euclid to implement a blazingly-fast alternative algorithm to find perfect numbers that will beat the pants off of exhaustive search. Buckle up! Your job is to implement the function: long findNthPerfectEuclid(long n) The exhaustive search algorithm painstakingly examines every number from 1 upwards, testing each to identify those that are perfect. Taking Euclid's approach, we instead hop through the numbers by powers of two, checking each Mersenne number to see if it is prime, and if so, calculate its corresponding perfect number. The general strategy is outlined below: Start by setting k = 1. Calculate m = 2k-1 (Note: C++ has no exponentiation operator, instead use library function pow) Determine whether m is prime or composite. (Hint: a prime number has a divisorSum and smarterSum equal to one. Code reuse is your friend!) If m is prime, then the value 2(k-1) * (2k-1) is a perfect number. If this is the nth perfect number you have found, stop here. Increment k and repeat from step 2. The call findNthPerfectEuclid(n) should return the nth perfect number. What will be your testing strategy to verify that this function returns the correct result? You may find this table of perfect numbers to be helpful. One possibility is a test case that confirms each number is perfect according to your earlier function, e.g. EXPECT(isPerfect(findNthPerfectEuclid(n))). Note: The findNthPerfectEuclid function can assume that all inputs (values of n) will be positive (that is, greater than 0). In particular, this means that you don't have to worry about negative values of n or the case where n is zero. Add at least 4 new student test cases of your own to verify that your findNthPerfectEuclid works correctly. Q9. Explain how you chose your specific test cases and why they lead you to be confident findNthPerfectEuclid is working correctly. A call to findNthPerfectEuclid(5) should near instantaneously return the fifth perfect number. Woah! Quite an improvement over the exhaustive algorithm, eh? But if you try for the sixth, seventh, eighth, and beyond, you can run into a different problem of scale. The super-fast algorithm works in blink of an eye, but the numbers begin to have so many digits that they quickly exceed the capability of the long data type (long can hold a maximum of 10 to 20 digits depending on your system. When a number gets too large, the value will unexpectedly go negative - how wacky is that? Take CS107 to learn more) So much for the invincibility of modern computers... As a point of comparison, back in 400 BC, Euclid worked out the first eight perfect numbers himself - not too shabby for a guy with no electronics! Warmup conclusions Hooray for algorithms! One of the themes for CS106B is the tradeoffs between algorithm choices and program efficiency. The differences between the exhaustive search and Euclid's approach is striking. Although there are tweaks (such as the square root trick) that will improve each algorithm relative to itself, the biggest bang for the buck comes from starting with a better overall approach. This result foreshadows many of the interesting things to come this quarter. Before moving on to the second part of the assignment, confirm that you have completed all tasks from the warmup. You should have answers to questions Q1 to Q9 in short_answer.txt. You should have implemented the following functions in perfect.cpp smarterSum isPerfectSmarter findPerfectsSmarter findNthPerfectEuclid as well as added the requisite number of tests for each of these functions. Your code should also have thoughtful comments, including an overview header comment at the top of the file. In the header comment for perfect.cpp, share with your section leader a little something about yourself and to offer an interesting tidbit you learned in doing this warmup (be it something about C++, algorithms, number theory, how spunky your computer is, or some other neat insight).
https://cs106b.stanford.edu/resources/python_to_cpp.html
Denoting Structure: Semicolons, Parentheses, and Braces In Python, indentation and whitespace indicates where statements end and how structures nest inside one another. In C++, you need to explicitly indicate this using semicolons, parentheses, and braces. Curly braces - the { and } characters - are almost exactly equivalent to Python indentation. You'll need to use them in if statements, for loops, while loops, and functions. For example: Python C++ def my_function(a, b): if a == 1: print(b) void myFunction(int a, string b) { if (a == 1) { cout << b << endl; } } Although indentation alone does not tell the C++ compiler how structures nest inside one another, it's important to indent things nonetheless to better convey the meaning of your code. When using curly braces, it's customary to put each close brace on its own line and aligned with the part of the code it's closing out. This makes it easier to see how things are nested. Parentheses - the ( and ) characters - also have the same meaning as in Python. The difference is that, in C++, several structures require the use of parentheses in places where they were optional in Python. For example, the conditions in an if statement and while loop require parentheses: Python C++ while x < 137: x = 3*x + 1 if x % 2 == 0: x /= 2 while (x < 137) { x = 3*x + 1; if (x % 2 == 0) { x /= 2; } } One of the more obvious differences between Python and C++ is the use of semicolons - the ;character. In Python, the end of a statement is denoted by a newline. In C++, every statement (except for control statements like for, if, and while) must end with a semicolon. For example: /***** C++ *****/ int number = 137; callAFunction(arg1, arg2); However, make sure that you do not put a semicolon after a control statement like for, if, or while. Similarly, do not put a semicolon at the end of a statement beginning with #. /***** Bad C++: Do Not Do This! *****/ #include "strlib.h"; // <-- Oops, no semicolon here! if (myNumber == 137); { // <-- Oops, no semicolon here! while (myNumber % 2 == 1); { // <-- Oops, no semicolon here! myNumber /= 2; } } Types C++ is a typed language, which means that you sometimes need to explicitly say what type something is. A type is a fundamental kind of value. Examples include int, string, char (single character, not in Python), double (equivalent of Python float). You must explicitly state the type when declaring a variable, but not while using it after that. For example: /***** C++ *****/ int number = 137; // Declare number; type needed number += 106; // number already declared; do not include type Function parameters must also have types; also, every function must include a return type. If the function doesn't return anything, it has return type void. However, you don't have to include the types when calling the function. Python C++ def pizkwat(a, b): return a + b def squigglebah(a, b): print(a + 2 * b) ooboo = pizkwat(1, 2) squigglebah(3, 4) int pizkwat(int a, int b) { return a + b; } void squigglebah(int a, int b) { cout << a + 2 * b << endl; } int ooboo = pizkwat(1, 2); squigglebah(3, 4); For Loops In Python, iterating over a range of numbers can be done using the for ... in loop. In C++, the syntax is a bit more involved: Python C++ for i in range(10): print(i) for (int i = 0; i < 10; i++) { cout << i << endl; } Conditionals The if and else keywords work basically the same way in C++ as they do in Python: Python C++ if myNumber == 137: print("Huzzah!") else: print("Alas!") if (myNumber == 137) { cout << "Huzzah!" << endl; } else { cout << "Alas!" << endl; } In C++, there is no elif keyword. Instead, write out else if as two words, like this: Python C++ if myNumber == 137: print("Yeehaw!") elif myNumber == 106: print("Golly gee!") else: print("Oh fiddlesticks.") if (myNumber == 137) { cout << "Yeehaw!" << endl; } else if (myNumber == 106) { cout << "Golly gee!" << endl; } else { cout << "Oh fiddlesticks." << endl; } In Python, you use and, not, and or to combine or modify predicates. While these keywords will technically work in C++, it's not considered good style to use them. Instead, use the (slightly more cryptic, but more standard) symbols && in place of and || in place of or ! in place of not For example: Python C++ if a == b and b == c: print("Norwuz") elif a == b or b == c: print("Rosh Hashanah") elif not predicate(a): print("Losar") else: print("Just a day.") if (a == b && b == c ) { cout << "Norwuz" << endl; } else if (a == b || b == c) { cout << "Rosh Hashanah" << endl; } else if (!predicate(a)) { cout << "Losar" << endl; } else { cout << "Just a day." << endl; } In Python, you can chain inequalities together. In C++, you cannot do this, and instead need to build multiple inequalities and use && to combine them together: Python C++ if 0 <= a < 10: print("One digit.") if (0 <= a && a < 10) { cout << "One digit." << endl; } Comments Python has single-line comments that start with #. In C++, we use // instead. Python C++ sporgle(quizbah) # Transform input sporgle(quizbah); // Transform input C++ also has multiline comments that can be used to describe a dense block of code. They begin with the sequence /* and end with */. For aesthetic reasons it's common to see each line of the comment starting with a star, but this isn't strictly necessary. Python C++ # Did you know that the ocean sunfish # is so large that, when a single # sunfish is accidentally caught by # a fishing boat, it can account for # about half the total catch? /* Did you know that the ocean sunfish * is so large that, when a single * sunfish is accidentally caught by * a fishing boat, it can account for * about half the total catch? */ Python uses docstrings to document what a function does inside the body of the function. In C++, the convention is to use a multiline comment before the body of the function: Python C++ def phchthshkh(o): """ This function name and argument name are terrible. They're just examples. """ return o * o /* This function name and argument * name are terrible. They're just * examples. */ int phchthshkh(double o) { return o * o; } Function Prototypes C++ (for the most part) uses a model called one-pass compilation. This means that the C++ compiler starts at the top of the program, reading downward, and only knows about functions that it's seen so far. As a result, if you want to call a function that you will eventually define but haven't yet gotten to writing, you need to include a prototype for that function at the top of the program. Python C++ def eclair(n): return croissant(n) def croissant(n): return n + 1 print(eclair(137)) int crossaint(int n); // Prototype int eclair(int n) { return croissant(n); } int croissant(int n) { return n + 1; } int main() { cout << eclair(137) << endl; return 0; } Strings and Characters C++ makes a distinction between strings and characters. A character (denoted by the type char) is a single glyph you can display on the screen. A string (denoted by the type string) is a sequence of zero or more characters. Anything in single quotes (e.g. 'a') is considered a char, while anything in doublequotes is considered a string (e.g. "a"). For example: Python C++ papyrus = 'a' # String of length 1 quill = "a" # String of length 1 quill = papyrus # Sure, no problem. papyrus = quill # Sure, no problem. char papyrus = 'a'; // Character string quill = "a"; // String quill = papyrus; // Error! Wrong types papyrus = quill; // Error! Wrong types Many string functions built into Python are not present in C++, but you can get the same functionality by using functions from the "strlib.h" header file. Python C++ text = "Pirate" if text.startswith("Pi"): print("A circle") if text.endswith("irate"): print("It's angry") if "ra" in text: print("Sun god!") if text.find("at") != -1: print("Preposition!") print(text.lower()) print(text.upper()) text = "a walk in the park" parts = text.split(' ') print(parts[0]) for part in parts: print(part) text = "137" value = int(text) text = str(value) #include "strlib.h" #include "vector.h" string text = "Pirate"; if (startsWith(text, "Pi")) { cout << "A circle!" << endl; } if (endsWith(text, "irate")) { cout << "It's angry!" << endl; } if (text.find("ra") != string::npos) { cout << "Sun god!" << endl; } if (text.find("at") != string::npos) { cout << "Preposition!" << endl; } cout << toLowerCase(text) << endl; cout << toUpperCase(text) << endl; text = "a walk in the park"; Vector<string> parts = stringSplit(text, " "); cout << parts[0] << endl; for (string part : parts) { cout << part << endl; } text = "137"; int value = stringToInt(text); text = to_string(value); Substrings Substrings in C++ work differently than in Python. In Python, the notation str[start:end] gives you a substring starting at position start and ending at position end. In C++, the function call str.substr(start, len) gives you a substring of length len starting just before position start. You can also use str.substr(start) to get a substring starting at position start and continuing to the end of the string. Negative indices are not allowed. Python C++ text = "appraising" # praising print(text[2:]) # raisin print(text[3:9]) print(text[3:-1]) string text = "appraising"; // praising cout << text.substr(2) << endl; // raisin cout << text.substr(3, 6) << endl; cout << text.substr(3, text.size() - 4) << endl;
https://cs106b.stanford.edu/schedule.html
This is a preview of our planned schedule. We will update this schedule as we go. This page should faithfully describe the past, but it won't always accurately predict the future. 1 Jan 8 Welcome! Jan 10 C++ Fundamentals Text Ch. 1, 2.1-2.4 Jan 12 C++ Strings Text 3.1-3.7 Welcome to CS106B! 2 Jan 17 Testing, Vectors, and Grids Text 2.5-2.9, 5.1 and class documentation for Vector and Grid Jan 18 C++ fundamentals Jan 19 Stacks and Queues Text 5.1 - 5.3, Class documentation for Stack and Queue 3 Jan 22 Sets and Maps Text 5.4, 5.5, Class documentation for Set and Map Getting Your C++ Legs Jan 24 Introduction to Recursion Text 7.1-7.3 Jan 25 ADTs Jan 26 Big-O and Algorithmic Analysis Text 10.2 4 Jan 29 More Recursion Text 8.1, 8.2, 8.3 Fun with Collections Jan 31 Recursive Problem Solving Text 8.4 Feb 1 TBA Feb 2 Recursive Backtracking and Enumeration Text 9.1-9.3 5 Feb 5 More Recursive Backtracking Text 9.1-9.3 TBA Feb 7 Sorting Algorithms Text 10.1-10.5 Feb 8 TBA Feb 9 Object-Oriented Programming Text 6.1-6.5 6 Feb 12 Pointers and Arrays Text 11.1, 11.2, 11.3 TBA Feb 14 Dynamic Memory Management Text 12.1, 12.3, 14.2 Feb 15 TBA Mid-quarter exam Feb 16 Priority Queues and Binary Heaps Text 14.3, 16.5 7 Feb 21 Applied Ethics Feb 22 TBA Feb 23 Introduction to Linked Lists Text 12.2, 13.5 8 Feb 26 More Linked Lists Text 14.2 - 14.4 TBA Feb 28 Binary Trees, Binary Search Trees, and Tree Traversals Text 16.1 Feb 29 TBA Mar 1 More on Binary Trees Text 16.2 - 16.4 9 Mar 4 Binary Trees: Loose Ends TBA 10 Mar 13 Huffman Coding TBA Mar 14 TBA Mar 15 Hashing Text 15.3 11 Mar 18 Graph Algorithms Mar 20 Dijkstra, A*, and Topological Sort Mar 22 Wrap 12 Mar 25 Ask-Me-Anything End-quarter exam
https://cs106b.stanford.edu/assignments/2-adt/searchengine.html
An introduction to search engines Search engines are one of the most influential developments of the modern internet age and have completely revolutionized how users interact with the web. What was once an intractable jumble of data with no semblance of organization has become a treasure trove of useful information due to the magic of search. Armed with the power of Map and Set, you can recreate this phenomenal achievement yourself. Once completed, you will understand the core technology underpinning Spotlight, Google, and Bing, and have solid practice in the use of the Map and Set ADTs. Want to see the power of search right now? Click Search in the top-right of the page navigation bar and search for easter egg to see what lurks deep in the recesses of the course website... In your search engine, each web page has a URL ("Uniform Resource Locator") that serves as its unique id and a string containing the body text of the page. You will first write functions that pre-process the body text and populate the data structure. Next you'll implement the function to search for pages matching a search query. Finally, you will write a console program that allows the user to enter many search queries and retrieve the matching web pages. Put all together, you will have built your own mini search engine! Understanding the web page data We have harvested the body text from the pages of our course website into a database file that is provided in the starter project. The format of the database file is as follows: The lines of the file are grouped into pairs with the following structure: The first line of a pair is a page URL. The second line of a pair is the body text of that page, with all newlines removed (the entire text of the page in a single string). The first two lines in the file form the first pair. The third and fourth lines form another pair, the fifth and sixth another, and so on, with alternating lines of page URL and page content. To view an example database, open the file tiny.txt or website.txt in the folder Other files/res of the starter project. Using an inverted index for searching To make our search efficient, we need to be thoughtful about how we structure and store the data. A poor choice in data structures would make search painfully slow, but clever use of our wonderful ADTs can avoid that fate. A search engine typically uses a nifty arrangement known as an inverted index. An inverted index is akin to the typical index in the back of a book. If you look up the keyword "internet" in the index of the CS106B textbook, it lists two page numbers, 18 and 821. The word internet occurs on page number 18 and again on page number 821. Thus, an inverted index is a mapping from word to locations. You look up a keyword in an inverted index to find all the locations where that keyword occurs. In contrast a forward index operates in the other direction. For our book example, the forward index would be a mapping from a location (page number) to all the words that occur on that page. To build an inverted index, you typically start with the data in the form of a forward index and then process to convert to the inverted form. Inverting the index takes time up front, but once complete, the inverted index supports extremely fast operations to find query matches. On to the code! Decomposition is one of your best tools for tackling a complex problem. We'll guide you along by breaking the problem down into a sequence of steps. Follow our steps to success! All of the functions and tests for the search engine are to be implemented in the file search.cpp. 1) Write helper function cleanToken() Start by writing a helper function for this small but key string-processing task: string cleanToken(string token) cleanToken takes in a string token and returns a "cleaned" version of the token, ready to be stored in the index. To clean a token, extract only the letter and number characters and convert all letters to lowercase, i.e. "Wow!" becomes "wow", mid-quarter" becomes "midquarter", and "CS106B" becomes "cs106b". Standardizing on this simple canonical form allows search queries to operate case-insensitively and ignore punctuation. You might want to start by reworking the code from the lettersOnly function you wrote for Soundex and change/extend as necessary. The return value from cleanToken is the cleaned lowercase version, or will be empty string if the token is to be discarded (i.e. contains no letter or number characters). Write test cases to confirm that cleanToken works correctly in all situations before moving on! You will make heavy use of cleanToken when building the inverted index and if this helper mishandles tokens, it will throw off your results and lead to sad times. It is definitely worth your time to confirm with a solid set of test cases before moving on. Remember to label your tests as STUDENT_TEST. 2) Write helper function gatherTokens() The helper function gatherTokens extracts the set of unique tokens from the body text. Set<string> gatherTokens(string bodytext) The argument to gatherTokens is a string containing the body text from a single web page. The function returns a Set of the unique cleaned tokens that appear in the body text. The function first tokenizes the body text - this means to separate the string into words using the space character as delimiter. Call the stringSplit function from the Stanford library for this task. Then call your cleanToken helper function on each token and store the cleaned tokens into a Set. No matter how many repeat occurrences of a given word are in the body text, repeatedly adding it to a set stores just the one copy, which makes this ADT ideal for gathering the unique tokens. Time to test! Add test cases that confirm the output from gatherTokens, so you will later be able to call on this function with confidence that it does its job correctly. 3) Create inverted index in buildIndex() The function buildIndex reads the content from the database file and processes it into the form of an inverted index. int buildIndex(string dbfile, Map<string, Set<string>>& index) The first argument to buildIndex is the name of the database file of the web page data, the second argument is the Map to be populated with data for the inverted index. The return value of buildIndex is the number of documents processed from the database file. Before starting to code, work through a small example on paper to ensure you understand the data structure you are trying to build. Open the res/tiny.txt database file and manually process the content to build the inverted index. Q7. List the contents of the inverted index built from the res/tiny.txt database file. When you are ready to start writing code, read the previous section Understanding the web page data to review the format of the database file. Look at the code we provided for readMazeFile in maze.cpp for an example of C++ code to open a file and read the contents into a Vector of lines. Feel free to reuse that code for buildIndex. For each page, you will call gatherTokens to extract the set of unique tokens. For each token in the page, you record the match to the page's URL by adding to its entry in the inverted index. The index is of type Map<string, Set<string>>, this map associates each keyword with the set of the URLs where that word occurs. The function returns the count of web pages that were processed. Our starter code contains some provided tests to get you started; add student tests of your own to ensure your coverage is comprehensive. Use a TIME_OPERATION test to confirm your function operates in reasonable time. Building the inverted index should generally not take more than 5 seconds. 4) Search using findQueryMatches() Next up is to implement the function: Set<string> findQueryMatches(Map<string, Set<string>>& index, string query) The query string can either be a single search term or a compound sequence of multiple terms. A search term is a single word, and a sequence of search terms is multiple consecutive terms, each of which (besides the first one) may or may not be preceded by a modifier like + or - (see below for details). The same stringSplit function used to divide the body text into tokens will be used to divide the query sentence into search terms. The matches to a query are found by following these rules: If the query is a single search term, the matches are the web pages containing that term. If the query contains two or more search terms, it is a compound query. The results for a compound query are a combination of the matches for the terms considered singly. When a query contains additional search terms, the matches for those terms are added to the existing results. (results will match either term) Hint: use Set operation unionWith A search term has a slightly altered meaning when the term is prefaced by certain modifiers: If the user prefaces a search term with +, then matches for this term are intersected with the existing results. (results must match both terms) Hint: use the Set operation intersect If the user prefaces a search term with -, then matches for this term are removed from the existing results. (results must match one term without matching the other) Hint: use the Set operation difference The same token cleaning applied to the body text is also applied to query terms. Call your helper cleanToken to process each search term to strip punctuation and convert to lowercase before performing the search for matches. Note that searching is case-insensitive, that is, a search for "binky" returns the same results as "Binky" or "BINKY". Be sure to consider what implications this has for how you create and search the index. Here are some example queries and how they are interpreted quokka matches all pages containing the term "quokka" simple cheap means simple OR cheap matches pages that contain either "simple" or "cheap" or both tasty +healthy means tasty AND healthy matches pages that contain both "tasty" and "healthy" tasty -mushrooms means tasty WITHOUT mushrooms matches pages that contain "tasty" but do not contain "mushrooms" tasty -mushrooms simple +cheap means tasty WITHOUT mushrooms OR simple AND cheap matches pages that match ((("tasty" without "mushrooms") or "simple") and "cheap") There is no precedence for the operators, the query is simply processed from left to right. The matches for the first term are combined with matches for second, then combined with matches for third term and so on. In the last query shown above, the matches for tasty are first filtered to remove all pages containing mushrooms, then joined with all matches for simple and lastly intersected with all matches for cheap. You may assume that the query sentence is well-formed, which means: The query sentence is non-empty and contains at least one search term If a search term has a modifier, it will be the first character A modifier will not appear on its own as a search term A + or - character within a search term that is not the first character is not considered a modifier The first search term in the query sentence will never have a modifier You can assume that no search term will clean to the empty string (i.e. has at least one letter) There is a lot of functionality to test in query processing, be sure you add an appropriate range of student tests to be sure you're catching all the cases. 5) Put it all together with searchEngine() Thus far, your amazing code has re-arranged a mass of unstructured text data into a highly-organized inverted index with instantaneous retrieval and fancy query-matching capability. Now take it over the finish line to build your own search engine! The final function to implement is: void searchEngine(string dbfile) This function implements a console program that works as follows: It first constructs an inverted index from the contents of the database file. It prints how many web pages were processed to build the index and how many distinct words were found across all pages. It enters a loop that prompts the user to enter a query For each query entered by the user, it find the matching pages and prints the URLs. When the user enters the empty string (""), this indicates they are done and the program finishes. After you have completed this function, your program should behave as shown in the transcript shown below. Example program run (executed by running searchEngine("res/website.txt") in main.cpp): Stand by while building index... Indexed 38 pages containing 5756 unique terms. Enter query sentence (RETURN/ENTER to quit): citation Found 3 matching pages {"https://cs106b.stanford.edu/assignments/2-adt/searchengine.html", "https://cs106b.stanford.edu/citation", "https://cs106b.stanford.edu/honor_code"} Enter query sentence (RETURN/ENTER to quit): expect_error Found 4 matching pages {"https://cs106b.stanford.edu/assignments/2-adt/maze.html", "https://cs106b.stanford.edu/assignments/2-adt/searchengine.html", "https://cs106b.stanford.edu/assignments/2-adt/warmup.html", "https://cs106b.stanford.edu/resources/testing_guide.html"} Enter query sentence (RETURN/ENTER to quit): style +grading Found 10 matching pages {"https://cs106b.stanford.edu/about_assignments", "https://cs106b.stanford.edu/assignments/1-cpp/", "https://cs106b.stanford.edu/assignments/2-adt/", "https://cs106b.stanford.edu/assignments/2-adt/searchengine.html", "https://cs106b.stanford.edu/index.html", "https://cs106b.stanford.edu/julieadvice", "https://cs106b.stanford.edu/lectures/02-cpp/", "https://cs106b.stanford.edu/resources/style_guide.html", "https://cs106b.stanford.edu/resources/submit_checklist.html", "https://cs106b.stanford.edu/whynoide"} Enter query sentence (RETURN/ENTER to quit): cs106l template -qt Found 3 matching pages {"https://cs106b.stanford.edu/course_placement", "https://cs106b.stanford.edu/faq", "https://cs106b.stanford.edu/resources/style_guide.html"} Enter query sentence (RETURN/ENTER to quit): main() completed. Way to go, you're well on your way to becoming the next internet search pioneer! Notes The res folder of the starter project includes two database files: tiny.txt is the small example used in the writeup and website.txt is the body text extracted from all of the pages in our course website (as of Jan 21). You can open these files in Qt Creator to view their contents. The project resource files are listed under Other files -> res. Your program can open a resource file by specifying the path as "res/myfilename". References Inverted Index on GeeksForGeeks Wikipedia article on Inverted Indexes Stanford Natural Processing Group on Tokenization Extensions If you have completed the basic assignment requirements and and want to go further, we encourage you to try adding an extension! A non-exhaustive list of potential extensions is listed below: Weights When you get the results from a Google search, they are ranked so that the more relevant results are first on the list. The current Google algorithm is a well-kept trade secret (though it was originally the Page Rank algorithm, named for its creator, then-Stanford graduate student Larry Page), but a simple approach is to give higher rank to pages with more occurrences of the search term. For this extension, you would need to re-think how you create your index to include the number of matches. Phrase search The assignment does not allow a search for multi-word terms, such as section leader. Searching for phrases is not trivial, as you cannot simply keep a mapping of all possible phrases in the document. You could, however, keep track of where in each document a word is, and then use that information to determine if words in a phrase are next to each other in any particular document. Stop Words The English language has many, many words that show up in text but are not particularly important for content, such as the, and, if, a, etc. These words are called Stop Words, and it would make your index smaller if you removed such stop words from the index. Here is more info about stop words. Stemming In the current design, if a user searches for section they won't find matches for sections, even though pages that mention either might be a relevant match. Stemming is the process of reducing words to their base form, so that (for example) both section and sections would become, simply, section in the index. If you have other creative ideas for extensions, run them by the course staff, and we'd be happy to give you guidance!
https://cs106b.stanford.edu/assignments/1-cpp/soundex.html
For the Soundex search portion of the assignment you will: study a real-world algorithm used by the U.S. Census to encode the phonetic pronunciation of surnames. implement the algorithm, developing a function that can take surnames as input and produce phonetic encodings as output. implement a console program that allows users to input a surname and then find all matches in a database of Stanford surnames that have the same encoding. respond to a few reflective questions on the efficacy and limitations of this algorithm. The coding is mostly C++ string processing, along with a little bit of file reading and use of Vector. You'll also be practicing with use of decomposition and a test-as-you-go strategy. The two files you will be editing are soundex.cpp (for the code) and short_answer.txt (for responses to thought questions). Why phonetic name matching is useful One of the more pesky features of the English language is the lack of consistency between phonetics and spelling. Matching surnames can be vexing because many common surnames come in a variety of spellings and continue to change over time and distance as a result of incorrectly inputted data, cultural differences in spelling, and transliteration errors. Traditional string matching algorithms that use exact match or partial/overlap match perform poorly in this messy milieu of real world data. In contrast, the Soundex system groups names by phonetic structure to enable matching by pronunciation rather than literal character match. This makes tasks like tracking genealogy or searching for a spoken surname easier. Soundex was patented by Margaret O'Dell and Robert C. Russell in 1918, and the U.S. Census is a big consumer of Soundex along with genealogical researchers, directory assistance, and background investigators. The Soundex algorithm is a coded index based on the way a name sounds rather than the way it is spelled. Surnames that sound the same but are spelled differently, like "Vaska," "Vasque," and "Vussky," have the same code and are classified together. How Soundex codes are generated The Soundex algorithm operates on an input surname and converts the name into its Soundex code. A Soundex code is a four-character string in the form of an initial letter followed by three digits, such as Z452. The initial letter is the first letter of the surname, and the three digits are drawn from the sounds within the surname using the following algorithm: Extract only the letters from the surname, discarding all non-letters (no dashes, spaces, apostrophes, ...). Encode each letter as a digit using the table below. Digit represents the letters 0 A E I O U H W Y 1 B F P V 2 C G J K Q S X Z 3 D T 4 L 5 M N 6 R Coalesce adjacent duplicate digits from the code (e.g. 222025 becomes 2025). Replace the first digit of the code with the first letter of the original name, converting to uppercase. Discard any zeros from the code. Make the code exactly length 4 by padding with zeros or truncating the excess. Note that Soundex algorithm does not distinguish case in the input; letters can be lower, upper, or mixed case. The first character in the result code is always in upper case. To ensure you understand the construction, get a piece of scratch paper and manually compute a few names, such as "Curie" (C600) and "O'Conner" (O256). Q10. What is the Soundex code for "Angelou"? What is the code for your own surname? Decomposing the problem Your best strategy for approaching a complex algorithm like this is to decompose the problem into smaller, more manageable tasks and proceed step by step, testing as you go. Q11. Before writing any code, brainstorm your plan of attack and sketch how you might decompose the work into smaller tasks. Briefly describe your decomposition strategy. To get you started, we're going to walk you through what it might look like to decompose and implement the first step of the Soundex algorithm. Decomposition is important here because if you tried to implement a single function that accomplished the whole Soundex algorithm all in one go, you could end up with one big, unwieldy piece of code. However, if you break down the problem into a number of different steps, each corresponding to its own helper function, you can develop these helper functions one at a time and test each one as you go. For example, Step 1 of the Soundex algorithm could be implemented as a helper function that extracts only the letters from a string. The C++ library function isalpha will report whether a character is alphabetic (i.e. is a letter). Here is a starting point (provided for you in soundex.cpp): // WARNING: Code is buggy! Add test cases to identify which inputs are mishandled string lettersOnly(string s) { string result = charToString(s[0]); for (int i = 1; i < s.length(); i++) { if (isalpha(s[i])) { result += s[i]; } } return result; } Testing, testing, testing With this draft implementation of lettersOnly, the next step is to test it. Our starter code includes some provided tests to get you started. Run the program and when prompted, select the option from the menu for tests from soundex.cpp. When you run these provided tests, you will see that the tests for the lettersOnly function all pass. From this, you might conclude that the function is good to go. However, there is a problem lurking within the code that has yet to be uncovered! Review our provided test cases to see what sorts of inputs we tested, and, more importantly, what sorts of inputs we didn't test. Brainstorm what those missing cases are and then add them. Think about edge cases that could lurk in the extremes or cases that are uniquely distinguished from the provided tests, such as a completely empty string or a string composed of only non-letter characters. Add at least 1 new student test to expose the bug in the given implementation of lettersOnly. Your goal in writing tests is to enumerate a comprehensive set of tests that brings any bugs in the code to light so you can debug and fix them. Good tests are the key to writing robust software. A great developer is not only a great coder, but also a great tester. Debugging a failing test case Once you have added a test case that fails, use the debugger to get more information about how the function has gone wrong. Set a breakpoint within the code block that contains your test case. A good place to stop is on the line with the operation that you want to trace through, like so: Now run the tests while using the debugger. When you hit the breakpoint, single step through the call to lettersOnly while watching the debugger's variables pane to see how the values are changing. This "step-and-watch" approach is the same as you used in the Assignment 0 debugging tutorial. Using the debugger should help you find the bug -once you understand it, go ahead and fix it! Implementing the Soundex algorithm With your fix, you have a working helper function that implements the first of the Soundex algorithm steps. Now for each subsequent step of the algorithm (encode, coalesce duplicates, and so on), follow the same process: Identify the next small task of the algorithm to implement. Define a new helper function to accomplish that task. Write student tests that confirm the expected behavior of the new function. Fill in the code for your helper function, debugging as you go. Continue writing code and debugging until you have passed all the tests from the previous step. Rinse and repeat. Your eventual goal is to implement the function: string soundex(string s) The top-level function will use the helper functions that you have written and tested. In addition to the test cases for the individual helper functions, you will also need test cases for the top-level function. The starter code has a number of provided test cases to get you started, but you should also add tests of your own to ensure you have covered the full possible range of inputs. Developing a census search program The capstone of this part of the assignment is to build a program that emulates the way in which the U.S. Census uses the Soundex algorithm. This console program allows a user to perform a Soundex search on a database of surnames. Implement the following function prototype: void soundexSearch(string filepath) The one argument to soundexSearch is the name of a text file containing a database of names. The program then repeatedly allows the user to enter a surname to look up in the database. For each surname that is entered, the program calculates the Soundex code of the entered name and then finds all names in the database that have a matching Soundex code. Here are the steps for the program: Read a database of surnames from the specified text file. This step is provided for you in the starter code. The "database" is simply a Vector<string>. Prompt the user to enter a surname. The function getLine from "simpio.h" will be helpful here. Compute the Soundex code of the surname. Iterate over the Vector of names, compute Soundex code of each name, and gather a result Vector containing those surnames with a matching code. Print the matches in sorted order. The Vector has a handy sort() operation (you can use vec.sort() where vec is the name of your vector), and you can print a vector using the << operator, e.g. cout << vec << endl;. Please note that the sort() function sorts the vector in place and does not return a value. Repeat steps 2-5 until the user indicates that they are done. To run the Soundex search program, you will need to change the main() function from its previous use in the perfect number warmup. Open the file main.cpp and edit the main() to comment out the call to findPerfects and uncomment the call to soundexSearch. Now when you run the program and select no tests, the main() function will execute and enter the Soundex search console program. Below is the output from a sample run of the program. If you are able to match this sample output exactly, then you have successfully completed this part of the assignment! Read file res/surnames.txt, 29409 names found. Enter a surname (RETURN to quit): Zelenski Soundex code is Z452 Matches from database: {"Zelenski", "Zelnik", "Zelnis", "Zielonka"} Enter a surname (RETURN to quit): hanrahan Soundex code is H565 Matches from database: {"Hammerman", "Haner-McAllister", "Hanrahan", "Honarmand"} Enter a surname (RETURN to quit): Back in main(): FINISHED! Considering limitations of Soundex Take a few moments to first watch this short video from Katie Creel, our CS Ethicist-in-Residence, giving some background context for the Soundex algorithm. You will need the content presented in this video to complete the ethical reasoning short answer questions below. A consistent theme of this class is that we want you to consider the ethical implications of the choice of algorithm. Like many of the algorithms we will encounter in CS106B, Soundex is used in real systems. For example, the U.S. Census has relied on a variation of the Soundex algorithm for almost a century. But just because it has been used in practice does not make it a perfect algorithm! Now that you understand how Soundex works, we want you to consider some of its limitations. Q12. Think about one or more examples of a class of names that the Soundex system might not work well for. Explain what this class of names is and why the system might incorrectly group them or mis-categorize one of the names. (Hint: You may find it useful to look over the other possible phonetic systems in Extending Your Phonetic Algorithm.) As you know, not all names can be represented using ASCII; many are more accurately represented using Unicode. However, ASCII is the default standard in C++ and many other programming languages and computer systems. The strings you've been working with in this assignment all use ASCII. Q13. Suppose you are a software engineer working for the U.S. government. You have been tasked with implementing a system that collects names as part of the Census survey and analyzes these names using a phonetic algorithm. Your boss suggests using Soundex and notes that the algorithm is only expected to work for ASCII-encoded strings, since supporting Unicode would require extra work and time. What would your response be and why? What representational harms might result from building a system that exclusively uses Soundex and/or ASCII? Additional advice for testing Testing is key for implementing this problem. Make sure that you take advantage of the SimpleTest testing framework! If a test is failing, put a breakpoint inside the failing test, and step through the code line by line using the debugger. Keep an eye on the variables pane -that will be your most helpful resource to figure out what is going wrong! The starter project includes a text file res/surnames.txt containing the surnames of Stanford students, faculty, and staff for the use of Soundex search. There are some 29,000 unique surnames within the Stanford community, wow! For early testing, you may want to change the program to read names from the file res/small.txt instead, which contains a tiny set of names that is easier to debug on. All of the input strings we will use to test your soundex function are guaranteed to contain at least one letter character. This means you do not have to make a special case in soundex to handle a string that doesn't any letters at all (e.g. no empty string or string containing only digits or punctuation). Useful resources On the Qt Creator window, there is search field in the lower left labeled with a magnifying glass icon. If you enter the name of a header file (e.g. strlib.h or cctype), Qt will display its contents. This is a quick way to review the features of a given library. You can also browse/search all library documentation online: Stanford C++ Library Documentation C++ Standard Library Documentation For this assignment, you will be using library functions that operate on strings and characters, in particular: The standard library string functions length, substr, concat, replace, etc. will be useful, along with the Stanford-specific string functions in strlib.h. For case conversions, you can use the functions in cctype to convert a single char or string functions in strlib.h to convert an entire string. Remember that C++ treats individual characters differently than strings of characters. Individual characters have type char and are enclosed in single quotes (i.e. 'a' not "a"). Strings have type string and enclose a sequence of characters in double-quotes (i.e. "hello" not 'hello'). There are helpful functions in strlib.h to aid you with converting between the two, including the charToString and stringToChar functions. In a similar vein, the integer 5 is a distinct beast from the digit character '5' or the string "5". Take care to express the type carefully to match your intentions. Our guide to C++ strings CS106B has a library of useful functions and collection classes including Vector, Set, Map and others, that are specifically designed for our ecosystem. All of these functions and classes are available for you to use. Bookmark the library documentation and keep it handy. You may have heard of similar collection classes provided in the C++ Standard Template Library (STL). Do not use the STL versions in CS106B. As a helpful mnemonic to distinguish between the two, our class names are always capitalized (Queue) whereas STL class names are all lowercase (queue). Stick to the capitalized ones! Our guide to Transitioning from Python to C++ Textbook Soundex references https://www.archives.gov/research/census/soundex Online Soundex code calculator: https://www.functions-online.com/soundex.html Extending your phonetic algorithm If you have completed the assignment and want to go further, we encourage you to try working on an extension! There are many other phonetic systems out there besides Soundex. Here is a non-extensive list: Daitch-Mokotoff Beider-Morse Metaphone New York State Identification and Intelligence System Try implementing one of these other systems and see if you can get better or more intuitive surname matches! When implementing an extension, add a new .cpp file to your project that contains the extension code, keeping it separate from the regular Soundex implementation. If you have other creative ideas for extensions, run them by the course staff, and we'd be happy to give you guidance!
https://cs106b.stanford.edu/resources/style_guide.html
You may think the motivation for good style is earning that from your section leader, but the most important beneficiary of your efforts is you yourself. Committing yourself to writing tidy, well-structured code from the start sets you up for good times to come. Your code will be easier to test, will have fewer bugs, and what bugs there are will be more isolated and easier to track down. You finish faster, your results are better, and your life is more pleasant. What's not to like? The guidelines below identify some of style qualities we will be looking for when grading your programs. As with any complex activity, there is no one "best" style, nor a definitive checklist that covers every situation. That said, there are better and worse choices and we want to guide you toward the better choices. In grading, we will expect that you make a concerted effort to follow these practices. While it is possible to write code that violates these guidelines and yet still exhibits good style, we recommend that you adopt our habits for practical purposes of grading. If you have theoretical points of disagreement, come hash that out with us in person. In most professional work environments you are expected to follow that company's style standards. Learning to carefully obey a style guide, and writing code with a group of other developers where the style is consistent among them, are valuable job skills. This guide gives our general philosophy and priorities, but even more valuable will be the guidance on your own particular style choices. Interactive grading with your section leader is your chance to receive one-on-one feedback, ask questions, and learn about areas for improvement. Don't miss out on this opportunity! Layout, Indentation, and Whitespace Indentation: Consistent use of whitespace/indentation always! Proper whitespace/indentation illuminates the structure of your program and makes it easier to follow the code and find errors. Increment indent level on each opening brace {, and decrement on each closing brace }. Chose an increment of 2-4 spaces per indent level. Be consistent. Do not place more than one statement on the same line. // confusing, hard to follow while (x < y) { if (x != 0) { binky(x); } else { winky(y); y--; }} return x; // indentation follows structure while (x < y) { if (x != 0) { binky(x); } else { winky(y); y--; } } return x; Long lines: When any line is longer than 100 characters, break it into two lines. Indent the overflow text to align with text above. // too long, can't see all result = longFunctionName(argument, 106 * expression * variable) + variable - longerFunctionName() + otherFunction(variable); // nicely reformatted result = longFunctionName(argument, 106 * expression * variable) + variable - longerFunctionName() + otherFunction(variable); Blank lines: Use blank lines to separate functions and logical groups of statements within a function. Whitespace: Add space between operators and their operands. Add parentheses to show grouping where precedence might be unclear to reader. // hard for reader to parse int root = (-b+sqrt(b*b-4*a*c))/2*a; // ah... breathing room! int root = (-b + sqrt((b * b) - (4 * a * c))) / (2 * a); Names Choose meaningful identifiers. This reduce the cognitive load for reader and self-documents the purpose of each variable and function. Nouns for variable names: For variables, the question is "What is it?" Use a noun (name,scores) add modifier to clarify (courseName, maxScore). Do not repeat the variable type in its name (not titleString, just title). Avoid one-letter names like a or p (exceptions for loop counters i, j or, coordinates x and y). Never name a variable l, much too easily confused with the number one. Verbs for function names: For functions, the question is "What does it do?" Functions which perform actions are best identified by verbs ( findSmallest, stripPunctuation, drawTriangle). Functions used primarily for their return value are named according to property being returned (isPrime, getAge). Use named constants: Avoid sprinkling magic numbers throughout your code. Instead declare a named const value and use where that value is needed. This aids readability and gives one place to edit value when needed. const int VOTING_AGE = 18; Capitalization: Use camel-case for names of functions and variables (countPixels), capitalize names of classes/types (GridLocation), and uppercase names of constants (MAX_WIDTH). Conventions allows reader to quickly determine which category a given identifier belongs to. Variable scope Scope: Declare variables in the narrowest possible scope. For example, if a variable is used only inside a loop, declare it inside the scope for the loop body rather than at the top of the function or at the top of the file. Don't reuse same name in inner scope: Declaring a variable in inner scope with same name as a variable in outer scope will cause inner use of name to "shadow" the outer definition. Not only is this confusing, it often leads to difficult bugs. No global variables: Do not declare variables at global scope. When there is information to be shared across function calls, it should flow into and out via parameters and return values, not reach out and access global state. Use of C++ language features Stanford library structures over STL structures: You should be using the data structures and other libraries included in the Stanford library instead of the ones included in the C++ standard template library (i.e. use Vector instead of vector) Prefer C++ idioms over C idioms: Since C++ is based on C, there is often a "C++ way" to do a given task and also a "C way". For example, the "C++ way" to print output is via the output stream cout, while the "C way" is using printf. C++ strings use the string class, older code uses the C-style char*. Prefer the modern C++ way. // old school char* str = "My message"; printf("%s\n", str); // modern and hip string str = "My message"; cout << str << endl; for vs while: Use a for loop when the number of repetitions is known (definite); use a while loop when the number of repetitions is unknown (indefinite). // loop exactly n times for (int i = 0; i < n; i++) { ... } // loop until there are no more lines string str; while (input >> str) { ... } break and continue in loops: Wherever possible, a loop should be structured in the ordinary way with clear loop start, stop, advance and no disruptive loop control. That said, there are limited uses of break that are okay, such as loop-and-a-half (while(true) with break) or need to exit loop mid-iteration. Use of continue is quite rare and often confusing to reader, better to avoid. Use of fallthrough in switch cases: A switch case should almost always end with a break or return that prevents continuing into the subsequent case. In the very rare case that you intend to fallthrough, add a comment to make that clear. Accidental fallthrough is the source of many a difficult bug. switch (val) { case 1: handleOne(); break; case 2: handleTwo(); // HEADS UP: fallthrough from case 2 into case 3 case 3: handleTwoOrThree(); return statements Although it is allowed for a function to have multiple return statements, in most situations it is preferable to funnel through a single return statement at the end of the function. An early return can be a clean option for a recursive base case or error handled at the beginning of a function. return can also serve as a loop exit. However, scattering other return throughout the function is not a good idea- experience shows they are responsible for a disproportionate number of bugs. It is easy to overlook the early-return case and mistakenly assume the function runs all the way to its end. Always include {} on control statements: The body an if/else, for, while, etc., should always be wrapped in {} and have proper line breaks, even if the body is only a single line. Using braces prevents accidents like the one shown below. // ugh if (count == 0) error("not found"); for (int i = 0; i < n; i++) draw(i); if (condition) doFirst(); doSecond(); // inside? Indent looks so, but no braces! // better if (count == 0) { error("not found"); } for (int i = 0; i < n; i++) { draw(i); } if (condition) { doFirst(); doSecond(); } Booleans: Boolean expressions are prone to redundant/awkward constructions. Prefer concise and direct alternatives. A boolean value is true or false, you do not need to further compare to true/false or convert a boolean expression to true/false. if (isWall == true) { ... } if (matches > 0) { return true; } else { return false; } // better if (isWall) { ... } return (matches > 0); Favor &&, ||, and ! over and, or, and not: For various reasons mostly related to international compatibility, C++ has two ways of representing the logical connectives AND, OR, and NOT. Traditionally, the operators &&, ||, and ! are used for AND, OR, and NOT, respectively, and the operators are the preferred ways of expressing compound booleans. The words and, or, and not can be used instead, but it would be highly unusual to do so and a bit jarring for C++ programmers used to the traditional operators. // non-standard if ((even and positive) or not zero) { ... } // preferred if ((even && positive) || !zero) { ... } Use error to report fatal conditions: The error function from the Stanford library can be used to report a fatal error with your custom message. The use of error is preferred over throwing a raw C++ exception because it plays nicely with the debugger and our SimpleTest framework. // raw exception if (arg < 0) { throw arg; } // preferred if (arg < 0) { error("arg must be positive!"); } Efficiency In CS106B, we value efficient choices in data structure and algorithms especially where there is significant payoff, but are not keen on micro-optimizations that serve to clutter the code for little gain. Better BigO class: Given a choice of options for implementing an algorithm, the preference is generally for the one with better Big O, i.e. an O(NlogN) algorithm is preferable to quadratic O(N^2), constant O(1) or logarithmic O(logN) beats out linear O(N). Choose best performing ADT for situation: For example, if you need to do many lookup operations on collection, Set would be preferable to Vector because of efficient contains operation. All Stack/Queue operations are O(1) making Stack an ideal choice if you only add/remove at top or Queue perfect if you remove from head and add at tail. There is a small win for choosing HashSet/HashMap over Set/Map when you do not require access to elements in sorted order. Save expensive call result and re-use: If you are calling an expensive function and using its result multiple times, save that result in a variable rather than having to call the function multiple times. This optimization is especially valuable inside a loop body. // computes search twice if (reallySlowSearch(term) >= 0) { remove(reallySlowSearch(term)); } // avoid recompute int index = reallySlowSearch(term); if (index >= 0) { remove(index); } Avoid copying large objects: When passing an object as a parameter or returning an object from a function, the entire object must be copied. Copying large objects, such as collection ADTs, can be expensive. Pass the object by reference avoid this expense. The client and the function then share access to the single instance. // slow because parameter is copied void process(Set<string> data) { ... } Vector<int> fillVector() { Vector<int> v; // add data to v ... return v; // makes copy } // pass by reference for efficiency void process(Set<string>& data) { ... } // shares vector without making copy void fillVector(Vector<int>& v) { // add data to v ... } Unify common code, avoid redundancy When drafting code, you may find that you repeat yourself or copy/paste blocks of code when you need to repeately perform the same/similar tasks. Unifying that repeated code into one passage simplifies your design and means only one piece of code to write, test, debug, update, and comment. Decompose to helper function: Extract common code and move to helper function. // repeated code if (g.inBounds(left) && g[left] && left != g[0][0] ) { return true; } else if g.inBounds(right) && g[right] && right != g[0][0] ) { return true; } // unify common into helper bool isViable(GridLocation loc, Grid<bool>& g) { return g.inBounds(loc) && g[loc] && loc != g[0][0]); } ... return isViable(left, g) || isViable(right, g); Factoring out common code: Factor out common code from different cases of a chained if-else or switch. // repeated code if (tool == CIRCLE) { setColor("black"); drawCircle(); waitForClick(); } else if (tool == SQUARE) { setColor("black"); drawSquare(); waitForClick(); } else if (tool == LINE) { setColor("black"); drawLine(); waitForClick(); } // factor out common setColor("black"); if (tool == CIRCLE) { drawCircle(); } else if (tool == SQUARE) { drawSquare(); } else if (tool == LINE) { drawLine(); } waitForClick(); Function design A well-designed function exhibits properties such as the following: Performs a single independent, coherent task. Does not do too large a share of the work. Is not unnecessarily entangled with other functions. Uses parameters for flexibility/re-use (rather that one-task tool). Clear relationship between information in (parameters) and out (return value) Function structure: An overly long function (say more than 20-30 lines) is unwieldy and should be decomposed into smaller sub-functions. If you try to describe the function's purpose and find yourself using the word "and" a lot, that probably means the function does too many things and should be subdivided. Value vs. reference parameters: Use reference parameters when need to modify value of parameter passed in, or to send information out from a function. Don't use reference parameters when it is not necessary or beneficial. Notice that a, b, and c are not reference parameters in the following function because they don't need to be. /* * Solves a quadratic equation ax^2 + bx + c = 0, * storing the results in output parameters root1 and root2. * Assumes that the given equation has two real roots. */ void quadratic(double a, double b, double c, double& root1, double& root2) { double discr = sqrt((b * b) -(4 * a * c); root1 = (-b + discr) / (2 * a); root2 = (-b - discr) / (2 * a); } Prefer return value over reference 'out' parameter for single value return: If a single value needs to be sent back from a function, it is cleaner to do with return value than a reference out parameter. // harder to follow void max(int a, int b, int& result) { if (a > b) { result = a; } else { result = b; } } // better as int max(int a, int b) { if (a > b) { return a; } else { return b; } } Avoid "chaining" calls, where many functions call each other in a chain without ever returning to main. Here is a diagram of call flow with (left) and without (right) chaining: // chained control flow main | +-- doGame | +-- initAndPlay | +-- configureAndPlay | +-- readCubes | +-- playGame | +-- doOneTurn // better structured as main | +-- welcome | +-- initializeGame | | | +-- configureBoard | | | +-- readCubes | +-- playGame | | | +-- doOneTurn Commenting Some of the best documentation comes from giving types, variables, functions, etc. meaningful names to begin and using straightforward and clear algorithms so the code speaks for itself. Certainly you will need comments where things get complex but don't bother writing a large number of low-content comments to explain self-evident code. The audience for all commenting is a C++-literate programmer. Therefore you should not explain the workings of C++ or basic programming techniques. Some programmers like to comment before writing any code, as it helps them establish what the program is going to do or how each function will be used. Others choose to comment at the end, now that all has been revealed. Some choose a combination of the two, commenting some at the beginning, some along the way, some at the end. You can decide what works best for you. But do watch that your final comments do match your final result. It's particularly unhelpful if the comment says one thing but the code does another thing. It's easy for such inconsistencies to creep in the course of developing and changing a function. Be careful to give your comments a once-over at the end to make sure they are still accurate to the final version of the program. File/class header: Each file should have an overview comment describing that file's purpose. For an assignment, this header should include your name, course/section, and a brief description of this file's relationship to the assignment. Citing sources: If your code was materially influenced by consulting an external resource (web page, book, another person, etc.), the source must be cited. Add citations in a comment at the top of the file. Be explicit about what assistance was received and how/where it influenced your code. Function header: Each function should have a header comment that describes the function's behavior at a high level, as well as information about: Parameters/return: Give type and purpose of each parameter going into function and type and purpose of return value. Preconditions/assumptions: Constraints/expectations that client should be aware of.("this function expects the file to be open for reading"). Errors: List any special cases or error conditions the function handles (e.g. "...raises error if divisor is 0", or "...returns the constant NOT_FOUND if the word doesn't exist"). Inline comments: Inline comments should be used sparingly where code complex or unusual enough to warrant such explanation. A good rule of thumb is: explain what the code accomplishes rather than repeat what the code says. If what the code accomplishes is obvious, then don't bother. // inline babbling just repeats what code already says, please don't! int counter; // declare a counter variable counter++; // increment counter while (index < length) // while index less than length TODOs: Remove any // TODO: comments from a program before turning it in. Commented-out code: It is considered bad style to submit a program with large chunks of code "commented out". It's fine to comment out code as you are working on a program, but if the program is done and such code is not needed, just remove it. Doc comments: You can use "doc" style (/** ... */) comment style if you like, but it is not required for this class. A style of commenting using // or /* ... */ is just fine.
https://cs106b.stanford.edu/resources/submit_checklist.html
This handy checklist is designed to help confirm your code is fully ready to go before you submit it. Before you send it in for grading, take a few minutes to work through this checklist. Functionality I've re-read the assignment writeup and verified my program matches the required specification. I've reviewed my code and understand each line of code I've written, why it's there, and why it's necessary. Test cases I've run all of the provided test cases against my code and resolved any test failures. I've supplemented the provided test cases with student tests of my own. For each part of the assignment, I've written at least one test case to make sure it works well in the common case. For each part of the assignment, I've thought of at least one edge case that could cause problems and written a student test for it. (And ideally, I've done this for multiple edge cases!) Style I've read the CS106B Style Guide at least once in its entirety and asked questions about any parts I don't understand. My code follows the guidelines from the Style Guide. My code meets the expectations for readability, decomposition, and program design and adheres to restrictions such as no global variables, no use of obscure language features, and so on. Each of my functions, conceptually, performs a single task. All of my variables and functions use clear and descriptive names. The dense parts of my code are commented, and those comments describe what the code accomplishes rather than restating the logic in plain English. Every function I've written has a comment preceding it that explains what the function does, what its parameters are, and what its return value (if any) means. Each file I am submitting has a header overview comment that clearly identifies the code authorship, including any necessary citations. Final Submission I've auto-indented my code in Qt Creator. The final layout is clean and readable. I've completed the tasks from all TODO comments in the starter code and removed those comments. I've removed all print statements left in the code that I used for debugging purposes. I've removed all commented-out blocks of code that are no longer necessary. I've read the Submit section of the assignment handout and confirmed that I'm submitting all of the required files.
https://cs106b.stanford.edu/resources/testing_guide.html
Why testing? Anybody that writes code for some purpose (whether as a researcher, a software engineer, or in any other profession) will get to the point where others are relying on their code. Bugs in software can be dangerous or even deadly. Additionally, users do not enjoy using software that is buggy and crashes, and fixing bugs once the software is in production is very costly. Most importantly, good engineers take pride in building things that work well and are robust. The key to writing working software is developing good tests. In this course we follow an approach called test-driven development. As you write code, you will also write companion tests. These tests are used to verify that the code you just finished writing works as intended. This strategy is sometimes called "test-as-you-go." You work in small steps, being sure to test thoroughly, and only move on after you having confirmed the correctness and fixed all issues. The beauty of this approach is that each step is relatively straightforward and easy to debug. Imagine the opposite approach: you write hundreds of lines of code, the code does not work, and now you need to figure out which one of those hundreds of lines of code isn't working as expected! That is the sort of frustration that we want to help you all avoid as you continue to develop your skills as programmers. SimpleTest For CS106B, we provide a unit-test framework called SimpleTest that you will use to test your code. This framework was pioneered by our ace colleague Keith Schwarz. SimpleTest provides a simple, clean approach to writing and running test cases. Here is an example of how you might see the SimpleTest framework used in the starter code of an assignment. // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) { string result; for (int i = s.length() - 1; i >= 0; i--) { result += s[i]; } return result; } /* * * * * * Test Cases * * * * * */ PROVIDED_TEST("Demonstrate different SimpleTest use cases") { EXPECT_EQUAL(reversed("but"), "tub"); EXPECT_EQUAL(reversed("stanford"), "drofnats"); } When we provide tests for you in the starter code, each test case is wrapped in the special macro PROVIDED_TEST. The string argument in parentheses describes the purpose of the test, and the code block that follows (enclosed in curly braces) defines the actual test behavior. When you add your own test cases, you will wrap your test code blocks in the STUDENT_TEST macro instead. The STUDENT_TEST functionality and structure are exactly the same as PROVIDED_TEST; it simply distinguishes the tests you've written yourself from those we provide for the benefit of your grader. You will see many examples of this in the following sections. EXPECT_EQUAL The test macro EXPECT_EQUAL(your_result, expected_result) tests whether your result matches the expected. A typical use for EXPECT_EQUAL compares a value produced by your code (e.g. the return value from a call to one of your functions) to the expected result and confirms they are equal. As an example, consider the first test case from the code above: EXPECT_EQUAL(reversed("but"), "tub"); This test case compares the result of the call reversed("but") to the expected answer "tub". If the two are indeed equal, the test will be reported as Correct. If they do not match, the test is reported as a failure. See below the added STUDENT_TEST code block with three tests of your own. These test cases use EXPECT_EQUAL to try out further scenarios not covered by the provided tests. /* * * * * * Test Cases * * * * * */ PROVIDED_TEST("Demonstrate different SimpleTest use cases") { EXPECT_EQUAL(reversed("but"), "tub"); EXPECT_EQUAL(reversed("stanford"), "drofnats"); } STUDENT_TEST("my added cases not covered by the provided tests") { EXPECT_EQUAL(reversed("racecar"), "racecar"); EXPECT_EQUAL(reversed(""), ""); EXPECT_EQUAL(reversed("123456789"), "987654321"); } Important note: You should never modify the provided tests -these are the same tests that will be used for grading, so it is not in your best interest to modify them. When adding tests, put them in a new STUDENT_TEST block of your own. EXPECT The EXPECT(expression) test case confirms the truth of a single expression. If the expression evaluates to true, the test is reported as Correct. If false, it reports a test failure. For example, if you added the isPalindrome function to the above program, you could add a test case that uses EXPECT to confirm the correct result from isPalindrome, as shown below. // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) { string result; for (int i = s.length() - 1; i >= 0; i--) { result += s[i]; } return result; } bool isPalindrome(string s) { return s == reversed(s); } /* * * * * * Test Cases * * * * * */ PROVIDED_TEST("Demonstrate different SimpleTest use case") { EXPECT_EQUAL(reversed("but"), "tub"); EXPECT_EQUAL(reversed("stanford"), "drofnats"); } STUDENT_TEST("test additional cases not covered by the provided tests") { EXPECT_EQUAL(reversed("racecar"), "racecar"); EXPECT_EQUAL(reversed(""), ""); EXPECT_EQUAL(reversed("123456789"), "987654321"); } STUDENT_TEST("test my isPalindrome function") { EXPECT(isPalindrome("racecar")); EXPECT(!isPalindrome("stanford")); } When would you use EXPECT instead of EXPECT_EQUAL? EXPECT_EQUAL is appropriate when you have a result that can be compared for equality to an expected result (e.g. two numbers, two strings, two Vectors, etc.). For most situations, confirming that your code "got the right answer" is exactly what you need. On the other hand, EXPECT allows you to express a wider variety of conditions beyond simple equality. For example, you could confirm the truth of a complex set of conditions by using a compound expression such as EXPECT(x > y && y != z || y == 0); EXPECT_ERROR The EXPECT_ERROR(expression) test macro is used to verify that evaluating the given expression raises an error (i.e. calls the error() function). If an error is raised, the test is reported as Correct. If not, the test is reported as a failure. As an example, EXPECT_ERROR(stringToInteger("cow")); would confirm that an error is raised when trying to convert the non-numeric string to a number value. EXPECT_ERROR is used in the specific situation of confirming expected handling of errors within your code. EXPECT_NO_ERROR The EXPECT_NO_ERROR(expression) is the opposite of the above. If the expression successfully runs to completion without raising an error, then the test is reported as Correct. The test is reported as a failure if the error() function is called. EXPECT_NO_ERROR is used in situations where you want to confirm that functions run to completion on correct input. TIME_OPERATION SimpleTest also has support for simple execution timing. The macro TIME_OPERATION(size, expression) is used to measure the time it takes to evaluate an expression, which is of the specified size. STUDENT_TEST("Time operation vector sort on tiny input") { Vector<int> v = {3, 7, 2, 45, 2, 6, 3, 56, 12}; TIME_OPERATION(v.size(), v.sort()); } The first argument to TIME_OPERATION is the input size; this is used to label this timing result in the output. The second argument is the expression to evaluate. TIME_OPERATION will start a new timer, evaluate the expression, stop the timer, and report the elapsed time. It is often useful to have a sequence of TIME_OPERATION on different sizes to see the larger pattern. Each operation is individually evaluated and timed. Below demonstrates use of TIME_OPERATION in a loop to time how long it takes to sort the items in successively larger vectors. STUDENT_TEST("Time operation vector sort over a range of input sizes") { for (int size = 50000; size < 1000000; size *= 2) { Vector<int> v; for (int i = 0; i < size; i++) { v.add(randomInteger(1, 1000)); // fill vector with random values } TIME_OPERATION(v.size(), v.sort()); } } Here are the test results for running the test cases above: Using TIME_OPERATION over a range of sizes lets you see how the time required for an operation changes with respect to input size - i.e. it predicts the algorithm's Big O. Handy! By default, a test case that uses TIME_OPERATION will be reported as Correct as long as the expression being evaluated does not result in an error or crash. If you want to verify the actual correctness of the result as well as time it, you can mix in regular use of EXPECT_EQUAL and EXPECT into the test case as shown below: STUDENT_TEST("Time operation vector sort on tiny input and verify is sorted") { Vector<int> v = {3, 7, 2, 45, 2, 6, 3, 56, 12}; TIME_OPERATION(v.size(), v.sort()); EXPECT(checkIsSorted(v)); } runSimpleTests The main function of our projects will begin by offering the user a choice in what to execute: run all the tests, select which tests to run, or run no tests and proceed with normal execution. It does this by calling the runSimpleTest function as shown below: int main() { if (runSimpleTests( <test choice argument> )) return 0; ... // rest of normal main() here } The argument to runSimpleTests is either: ALL_TESTS (run all tests for all files) SELECTED_TESTS (provide menu for user to select which tests to run) The user can enter zero for "no tests", which causes the program to continue with rest of main() Debugging a failing test Your goal when testing your code should be to get all of your tests to pass. However, if you get a failed test result, don't look at this as sad times; this test result is news you can use. The failing test case indicates an operation that behaved unexpectedly. This means you know where to focus your attention. Dig into that test case under the debugger to analyze how it has gone astray. Set a breakpoint inside the text code block, and choose to stop at the line that is at or before the failing EXPECT/EXPECT_EQUAL statement. Now run the tests using the debugger. When the program stops at the breakpoint, single-step through the code while watching the variables pane to observe how the state of your program changes, using a technique just like you did in the debugging tutorial in Assignment 0. After you understand the failure and apply a fix, run that test again. When you see the test pass, you can celebrate having squashed that bug! Debugging your test cases Your test cases are implemented as code, which means that they, too, can have bugs of their own. Having a bug in your test case can truly be a maddening experience! A test case that produces a false negative can lead you to investigate a non-existent defect and a false positive lulls you into overlooking a lurking one. You attribute the erroneous test result to the code being tested, yet the real issue is within the test case itself. Unlike hackneyed sitcom plots, hilarity does not ensue from this misunderstanding. For example, suppose you have written a function that returns the square of a number. You write some tests for it: int square(int n) { return n * n; } STUDENT_TEST("confirm my square function works correctly for 5, 10, and 15") { EXPECT_EQUAL(square(5), 25); EXPECT_EQUAL(square(10), 100); EXPECT_EQUAL(square(15), 275); // this test case is BUGGY! } The first two tests pass but the third will fail. The square of 15 is actually 225, not 275. The problem isn't with the square() function, but with the buggy test case that produces a false negative. Every programmer can relate to a time when a buggy test case reported an erroneous failure that led to wild goose chase to find a non-existent flaw in code that was correct all along, argh! There can also be tests that produce a false positive, i.e. report that code is Correct when it has a defect. This could be due to a buggy test case that compares to the wrong expected value, such as shown above. Another source of false positives is when your test cases are not sufficiently robust or comprehensive to surface the problem. If square() returned the wrong value only for negative inputs and your test cases only tested positive inputs, you would receive all Correct results and no mention of the lurking defect. Or perhaps you took a shortcut and wrote your test cases to only confirm that square() returned a non-negative value (e.g. EXPECT(square(15) >= 0)) without checking the specific value. These test cases are not buggy per se, but they are not thorough enough to fully vet the code being tested. A key takehome is that your test results are meaningful exactly and only if your test cases accurate and robust. Put extra care into verifying each test case is properly constructed and produces accurate results. Ensure your suite of test cases cover a comprehensive range of scenarios, including unusual inputs and edge conditions. Now when your program earns its clean sweep of Correct results, you can celebrate that success with confidence! Test-driven development We highly recommend employing test-driven development when working on your assignments. To do so, follow these steps: identify a small, concrete task (bug to fix, feature to add, desired change in behavior) construct tests for the desired outcome, add them to the file in which you're currently working, and verify the current code fails these tests implement the changes in your code to complete the task re-run your newly added tests and verify they now succeed test the rest of the system (by running all tests) to verify you didn't inadvertently break something else This process allows you to change only a small amount of code at once and validate your results with carefully constructed tests before and after. It keeps your development moving forward while ensuring you have a functional program at each step! Test cases and grading The SimpleTest framework will be supplied with each assignment, and there will be some initial test cases provided in the starter project, but you will also be expected to add your own tests. You will submit your tests along with the code, and the grader's review will consider the quality of your tests. We will also provide comments on your tests to help you improve your testing approach. Please incorporate our feedback into future assignments; it will improve your grade and, more importantly, your effectiveness as a programmer. We guarantee future employers will appreciate your ability to write good tests and well-tested code! Here are some things we look for in good tests. Are the tests comprehensive? Is all the functionality tested? Where possible, are the tests self-contained and independent? Did you anticipate potential problems, tricky cases, and boundary conditions? Did you develop the tests in a good order? Did you test basic functionality before more advanced functionality? Did you take small, carefully chosen steps? Common questions Should each EXPECT/EXPECT_EQUAL be in a STUDENT_TEST code block of its own or can I list several within one code block? For tests that are closely related, it may be convenient to group them together in the same code block under one test name. The tests will operate as one combined group and show up in the report as one aggregate success (if all pass) or one failure (if at least one fails). However, there are advantages to separating each individual test case into its own code block. You will be able to choose a clear, specific name for this block. The separation isolates each test so you can easily identify exactly which cases are passing and which are failing. For example, if you have, STUDENT_TEST("Many tests together") { EXPECT(... Test A ...) EXPECT(... Test B ...) EXPECT(... Test C ...) } then if Test B fails, Test C will never run and you won't be able to see the output - you won't know if Test C passed or failed. On the other hand, if you structure your tests like this STUDENT_TEST("Test A") { EXPECT(... Test A ...) } STUDENT_TEST("Test B") { EXPECT(... Test B ...) } STUDENT_TEST("Test C") { EXPECT(... Test C ...) } then all the tests will run individually, and even if Test B fails, you will still get independent information about Tests A and C. Having this sort of isolated behavior might make debugging any problems you encounter a little bit easier! When an assignment requirement says to "add 2 tests," do we count each STUDENT_TEST or each EXPECT_EQUAL? Each use of EXPECT/EXPECT_EQUAL is counted as one test case. Read the answer to the previous question for some things to consider when deciding whether to group multiple test cases under a single STUDENT_TEST group or keep separated. The font/sizes/colors in the Simple Test result window are not pleasing to me. Can I customize the display? Yes! Look in the Qt project browser under Other files->testing for a file named styles.css. This file is the CSS stylesheet for the Simple Test window. Edit this file to change the display styles. Each project has its own copy of the stylesheet. Copy the edited stylesheet from this project into a new project to carry those customizations forward.
https://cs106b.stanford.edu/tutoring
You are welcome to make use of tutoring resources, both on-campus and off-campus, to help solidify conceptual content, to deepen understanding of course topics, to fill gaps in understanding, and to work through ungraded practice problems. Tutoring can be a great way to work through topics you're having trouble understanding and to get input from someone with more experience than you. Tutoring, however, is not appropriate for help with work that will be submitted for a grade. When you have questions about the assignments or exams, please direct them to the course staff - we're happy to help out! Our formal tutoring policy is as follows. The word "tutoring" has a broad meaning, and we'll interpret it to mean any assistance with the course content or topics from someone who is not currently enrolled in the course and is not a member of the course staff. For example, CTL and AARC tutors and help websites like Chegg or Stack Overflow count as tutoring. Similarly, support or advice from past students (say, someone in your dorm who has already completed a course you're taking) counts as tutoring. We consider anyone who offers you support in this context is a tutor, regardless of formal titles. We also treat generative AI tools as a tutor. Tutoring must abide by the following rules for CS106B Tutors must be familiar with the Honor Code policy for a course prior to giving help. Importantly, not knowing the Honor Code and tutoring policies for a course does not protect you or your tutors from any Honor Code infractions. A student and tutor should review the course Honor Code policy together to set appropriate expectations and establish clear boundaries. Tutors must not review, look at, offer advice, or otherwise offer assistance with any work that you will submit for a grade or which could be reasonably expected to be submitted for a grade. This means, among other things, that tutors cannot help debug or write code for or related to programming assignments, review written proofs, etc. Tutors must not refer to course materials from previous offerings of the course. For example, tutors are not allowed to refer to lecture slides or solution sets used in previous quarters. They are permitted to reference the current quarter's materials, subject to the restrictions from (2). Tutors must not share any other student's work with you, including their own. For example, tutors may not share past submitted problem sets or coding assignments as a reference, even if the tutor was the original author of that work. Tutors and students are obligated under the Honor Code to "do their share and take an active part" in seeing to it that students and tutors do not ask for or receive unpermitted aid. Course instructors may, at their discretion, place additional limits on permitted tutoring. It is the responsibility of both students and tutors to be aware of and follow these rules. Failure to abide by these rules may constitute a violation of the Honor Code. If you have any questions about what is and is not permitted, either as a student or as a tutor, please contact the course instructor directly. We're happy to clarify our policies and help ensure folks get the support they need while keeping everything above board. Use of generative AI Generative AI tools have the potential to be a valuable supplement or perhaps even replacement of human tutors. However, use of these tools must adhere the tutoring policy. You may use such tools for help that is allowed for human tutors (such as help in understanding course concepts or working through practice problems), but it is disallowed to use these tools for assistance on work that will be submitted for a grade.
https://cs106b.stanford.edu/assignments/2-adt/warmup.html
"How I got better at debugging" by Julia Evans For this course, you will write many C++ programs. But writing the code is only the first step; you also need strong skills in testing and debugging to bring a program to successful completion. Knowing your way around the debugger is key. Our assignments will feature warmup exercises that are designed to give you guided practice with the skills and tools for effective testing and debugging. This warmup exercise demonstrates use of the debugger and testing on the ADT types. You are to answer the questions posed below by writing your answers in the file short_answer.txt. This file is submitted with your assignment. 1) View ADTs in debugger (manually configure if needed) Look over the provided code in adtwarmup.cpp that operates on Stacks and Queues. Some of this code is buggy and provided for the purpose of practicing your testing and debugging skills. The reverse function is implemented correctly and does not have bugs. It uses a Stack to reverse the contents of a Queue. Build and run the program. When prompted, enter the choice to run tests from adtwarmup.cpp. The reverse function should pass its single test case. (Ignore the test failures reported for the other functions, we'll get to those in a bit). Use the reverse function to practice debugging an ADT. In the file adtwarmup.cpp file, set a breakpoint on the first while loop in reverse. Now run the program in Debug mode. When prompted, select the tests for adtwarmup.cpp. When the debugger stops at your breakpoint, look at the Variables pane in the upper-right of the Qt Creator window. You should see the variables num, q , and s. Expand the variable q by clicking the triangle to the left of its name. The expanded contents of the Queue should look like this: IMPORTANT: If the Queue contents in your debugger look very different than the screenshot above, this likely means that your debugger is not configured to properly display variables of Stanford collection type. Stop here and follow the instructions to configure your Qt debugger. The Queue q was passed as an argument to reverse; its contents were initialized to {1, 2, 3, 4, 5}. The Stack s and integer num are declared as local variables in reverse. Neither of these variables is assigned an initial value. In the debugger variables pane, s is displayed as a Stack containing <0 items>. A Stack has a "default" initializer that configures a new stack that is not otherwise initialized. The default initializer for Stack makes an empty stack. In fact, all of the Stanford collection classes have a default initializer that creates an empty collection. Compare that behavior to what you see for the integer variable num. Like s, the variable num was declared without being initialized. Unlike the collection types, the int type does not have a default initializer. This means an int variable is left uninitialized. The debugger shows the "value" for num but that value is only the leftover contents in the memory location where num is being stored. In the screenshot above, the leftover value happened to be 28672, but you may see something different on your system. If your code erroneously tries to use the value of an uninitialized variable, you get an unpredictable result. For now, just file this fact away. If at some later point in debugging, you observe a variable holding a nonsensical value, check to see if the bug is a missing initialization. Use the Step Over button to single-step through the first iteration of the while loop. After executing the assignment to num, its value now becomes sensible. Stepping the next line pushes that value onto the stack. Expand the Stack s by clicking the triangle to the left of its name. You should now have both the stack and queue expanded. Continue single-stepping through the loop. As you step, keep your eye on the Variables pane and watch how the contents of the stack and queue are changing. Q1. The display of the Queue in the debugger uses the labels front and back to mark the two ends of the queue. How are the contents labeled when the Queue contains only one element? You now know how to inspect and interpret ADTs in the debugger. We hope that you will find this a useful skill when working on the rest of the assignment. 2) Test duplicateNegatives Testing and debugging are closely related. After writing a piece of code, you will want to test it to verify its behavior. If you encounter a problem, you run your test case under the debugger to further diagnose the bug. The intention of the function duplicateNegatives is to modify a Queue<int> to duplicate each negative number, i.e. turning the queue {3, -5, 10} into {3, -5, -5, 10}. The given code is buggy and does not behave correctly on all inputs. The provided test cases try inputs containing negative and positive numbers. Run those tests and take note of which tests pass and which do not. The test results show the function produces an incorrect result for a queue containing a negative value. Your hypothesis is that it is the presence of any negative number that triggers the bug. Before you start on debugging, you want to winnow down to the most minimal case. Thus you decide to try a queue of length one containing a single negative number. Write your own STUDENT_TEST for this case. Run the tests again. This new case seems to be taking a really, really long time to run. In fact what is happening is that the program is stuck in an infinite loop. A infinite loop is one that never reaches its stopping condition and thus never completes. When a program is stuck an infinite loop, your only recourse is to manually intervene. Pro tip: how to stop a stuck program If not running in Debug mode, you can stop the program by closing the console window or choosing "Quit" from the menu bar. This action forcibly exits the program. If running in Debug mode, you can interrupt the program. On debugger tool bar, find button with this icon (hover over to confirm tool tip action is "Interrupt"). Clicking this button will pause program execution and return control to the debugger. (This is same action as choosing "Debug"- > Interrupt" from application main menu). The program state is preserved and can be examined. This will allow you to gather more information to diagnose what's gone wrong. Our new test case deepens our understanding of the behavior of duplicateNegatives? We believe the function works correctly for non-negative inputs. For inputs containing mixed positive and negative values, the function completes but produces the wrong result. Your new test shows there is also a third category, where some inputs go into an infinite loop. Precisely identifying what kind of inputs trigger a problem is very helpful, as this will focus the debugging process. You have observed that an input of a single negative number results in an infinite loop. Is there more to the pattern? Could it be specific to where the negative number occurs in the input, such as being the first or last ? Add more student test cases and re-run until you narrow in on the precise trigger for the infinite loop. Gather the results of your observations and answer the following questions in short_answer.txt: Q2. For which type of inputs does the function go into an infinite loop? Rather than identify one specific input, describe the general characteristics of all such inputs. 3) Debug duplicateNegatives Now that you've observed the buggy behavior and know what kind of input triggers it, let's use the debugger to diagnose the flaw. (You may have already seen the bug when reading over the code; if so, great! But the purpose of this exercise is to show you a methodology for using the debugger that will help you in later times when you cannot spot the bug just from reading the code.) Start with your test case that goes into an infinite loop. Set a breakpoint on the call to duplicateNegatives within the test case and run the program in Debug mode. When the breakpoint is hit, Step Into the call to duplicateNegatives and then use Step Over to single step through a few iterations of the for loop. Expand the variable q to see its contents and pay attention to the changing values for i and q. Trace out what is happening and work through why the loop never reaches its intended termination condition. Given the above detective work, come up with a fix for the duplicateNegatives code. Try out your fix and see that it resolves the problem with the infinite loop inputs. As a followup, re-test the inputs that terminated but produced incorrect results. You should find they are also working correctly now. In this case, the same underlying flaw was producing two seemingly unrelated symptoms. Debugger use for the win! Answer the following question in short_answer.txt: Q3. Show your edited code for duplicateNegatives that fixes the problem with the infinite loop. 4) Diagnose a test that raises an error The last part of the warmup is learning how to recognize when a test case fails due to raising an error. The function sumStack is intended to return the sum of the values in a Stack of integers. Run the provided test cases. The first test is successful, but the subsequent test goes down in flames due to an error. When an error is raised in the middle of a test, SimpleTest reports it like this: Test failed due to the program triggering an ErrorException. This means that the test did not fail because of a call to EXPECT() or EXPECT_ERROR() failing, but rather because some code explicitly called the error() function. When you see this message, it means a fatal error was raised during test which prevented the test from completing. The error was not expected and due to a bug in the code. Sometimes there is additional commentary which further explains the specifics of the error, e.g. index out of bounds, attempt to pop from an empty stack, or modification of a collection while iterating over it. Use the same debugging process for an error as a failing test case: add a breakpoint inside the test case and step through to see where it goes wrong. If you put a breakpoint inside the test case code before the call to sumStack, your stepping will go through the behind-the-scenes code that sets up for the function call, including make a copy of the stack (the parameter is pass-by-value). This code is a bit goopy, so if instead set breakpoint on the first line of sumStack, this will stop after those function call shenanigans and you can get on to stepping through the operation of sumStack. There is one added twist to be aware of when stepping through code that has an error - you can step up to, but cannot step through the actual operation that raises an error. When executing the statement in error, a clever bit of C++ "hyperjumps" control to an error-handling routine (or your program may terminate if the error is more catastrophic). You must restart the program and step over until the crash again to get back to the context right before the crash. Looking at the code and stepping in the debugger, you will see that the bug in sumStack is due to mishandling an empty stack. One possible fix to sumStack would be to add a special case, i.e. inserting this code at the top of the function: int sumStack(Stack<int> s) { if (s.isEmpty()) { return 0; } ... However, there is a better fix to the existing code that would make it work correctly for both empty and non-empty stacks, without adding a special case. Q4. What is the better fix to sumStack that corrects the bug? That's it for the warmup! Be sure to keep these debugging techniques in mind when you find yourself in a future jam- the debugger is a friend you don't want to be without!
https://cs106b.stanford.edu/whynoide
There will come a time (paper exams, job interview, whiteboard talk) where you will be asked to write code without an IDE. Writing code without having the ability to run it is a somewhat different experience than writing code in Qt Creator. Specifically: You will not have a compiler that can point out syntax errors. You can't run the code, tweak it, and revise it until it works. You cannot run test cases against your code. You can't step through your code in a debugger. This means that the process by which you'll need to problem-solve is different. You'll need to sketch out where you're going a bit more than what you're used to doing in Qt Creator, and you'll need to be comfortable switching from a high-level idea to something more concrete. Additionally, you'll need to be pay a bit more attention to details, since there isn't going to be a compiler to catch your errors for you. But there is upside in this format we won't be evaluating your code using the standard of "does it compile, run, and work flawlessly?" If we did that, chances are most people would get zero points because a single misplaced brace or stray semicolon would derail everything. Instead, we'll be asking questions like these: Do you demonstrate a solid command of the C++ syntax we've covered so far? Does the approach you've taken demonstrate a good understanding of how to choose and apply an appropriate problem-solving strategy? Is your code well-structured in a way that shows a facility with breaking larger problems down into smaller pieces? In the IDE, even the smallest typo or syntax error stops the entire program in its tracks. On paper, we don't even deduct for these kind of errors if we are otherwise confident of what you intended. A conceptual problem using the wrong recursive strategy in a recursion problem or the wrong container type in a question on collections would be a more serious concern. In this context, we won't be grading for style at the same level as what we'd be looking for on the assignments - we understand that we're essentially grading a first draft. However, you should still aim to make your code easy to read. For example: Please use descriptive variable and function names. Single-letter variable names (or worse, single-letter function names) make it significantly harder to understand your code. Please properly indent your code. This is especially important in the event that you forget curly braces somewhere and we need to make an educated guess as to what you intended to do. If possible, give comments demarcating the different parts of your code. This isn't required, but if you have anything you think is really gnarly, it never hurts to add a comment explaining what you were trying to do! There are a few details we don't care about, so let's save you some time: You don't need to add #include statements at the top of your code. Assume they're all there. You don't need to write function prototypes. Why not an IDE? Students often ask why exams are not done like assignments: using a compiler, having code completion and searchable documentation, being able to run, test, and debug, etc. We have tried this in the past and it didn't work they way we'd hoped. What we learned was that the immediate feedback from the IDE more of an impediment than an advantage in these situations. Imagine this scenario: you read the first problem and have a good idea how to solve it. It takes you 20 minutes to draft a solution. You trace its operation and feel good about it. Let's say your answer is most correct, has minor syntax issue and a small bug that causes a few inputs to be improperly handled. Overall it would earn 8/10. But if you can compile it, you certainly will. You have to fiddle with resolving syntax issues (that were likely not even scored). Next you spend time testing it. Although testing confirms it works correctly for most inputs, you now see that it has a bug. So you hunker down and rework and retest until perfect. Having spent an additional 20 minutes fixing these issues earns you a perfect 10/10, but the extra effort for the final 2 points was a tiny payoff and you have less time for the remaining problems The even more devastating outcome were students who just plain got stuck on a bug and never advanced past the first or second problem. No matter how much we advised students to draft a good answer and keep moving, if confronted with direct evidence that the answer was not fully correct it was near impossible to move on. We know there are limitations to working without the benefit of a compiler and debugger, and we account for that in how we design and grade the exam. We are assessing your ability to think logically and use appropriate problem-solving techniques. We expect you to express yourself in reasonably correct C++, but we will be quite lenient with errors that are syntactic rather than conceptual.
